# **Product Requirements Document: Freelancer Tax Assistant (Production Spec)**

* **Version:** 2.1  
* **Date:** 2025-04-22  
* **Author:** Senior Software Engineer  
* **Status:** Draft

**Note:** This version incorporates requirements for production-grade features, significantly expanding the scope beyond the original assessment prototype. Development time and effort will be substantially higher.

## **1\. Introduction**

This document outlines the requirements for the "Freelancer Tax Assistant," a modern, conversational web application targeting freelancers. Users can engage in multi-turn conversations about tax-related questions, receiving informative, structured answers generated by selectable Large Language Models (LLMs). The application prioritizes security, reliability, and user experience, incorporating production-grade monitoring, logging, alerting, and persistent user history. The system supports both authenticated users with cross-device access and guest users with device-specific history, ensuring a seamless experience regardless of authentication status.

## **2\. Goals & Objectives**

* **Primary:** Deliver a secure, scalable, and reliable conversational AI application providing accurate tax information for freelancers.  
* **User Engagement:** Enable multi-turn conversations, allowing users to ask follow-up questions and refine their queries naturally.  
* **Accessibility:** Remove barriers to entry by allowing immediate use without registration while still providing persistent history.
* **Flexibility:** Support multiple underlying LLMs, allowing for potential selection based on user preference or performance characteristics.  
* **Reliability & Ops:** Implement comprehensive monitoring, logging, and alerting to ensure high availability and facilitate prompt issue resolution in a production environment.  
* **Security:** Integrate robust security measures to protect the application and its users from common threats.  
* **Persistence:** Provide users with persistent access to their query history across sessions.

## **3\. Functional Requirements (User Stories)**

### **Basic Interaction**

* **FR-01:** As a user, I want to access the web application via a standard web browser on both desktop and mobile devices.  
* **FR-02:** As a user, I want to see a clear text input area where I can type my tax-related question.  
* **FR-03:** As a user, I want to submit my message by clicking a button or pressing Enter.  
* **FR-04:** As a user, I want to see a visual indicator (e.g., loading spinner) while the application is processing my message.  
* **FR-05:** As a user, I want the AI-generated response to be displayed clearly in a conversational format with proper markdown formatting (bullets, sections, bold highlights).  
* **FR-06:** As a user, I want to see information about the LLM token usage for each turn of the conversation.  
* **FR-07:** As a user, I want to always see a disclaimer indicating that responses are not legal or financial advice.  
* **FR-08 (System):** The backend API must expose endpoints to manage conversational interactions.

### **Multi-Turn Conversation**

* **FR-11 (Multi-Turn):** As a user, I want the AI to remember the context of our current conversation, so I can ask follow-up questions without repeating previous information.  
* **FR-12 (System \- Multi-Turn):** The backend must manage conversation state (context) across multiple requests within a user session. This context must be passed to the LLM API on subsequent turns.

### **LLM Selection**

* **FR-13 (LLM Selection):** As a user, I want to optionally select which underlying LLM (e.g., Gemini, ChatGPT, Claude) powers the conversation, perhaps via a settings menu. (Default can be pre-set).  
* **FR-14 (System \- LLM Selection):** The backend must include an abstraction layer to interact with multiple different LLM APIs. API keys and configurations for all supported LLMs must be securely managed. The API must handle requests to use a specific LLM for a given conversation or user setting.

### **Persistent History**

* **FR-15 (Persistent History):** As a user (authenticated or guest), I want my conversation history to be saved automatically and persistently, so I can access it again from the same device or across devices (if authenticated).  
* **FR-16 (System \- Persistent History):** The backend must securely store user conversation history (queries, responses, context, timestamps) in a persistent database (e.g., PostgreSQL, MongoDB). For authenticated users, conversations are linked to user accounts. For guest users, conversations are linked to a secure device identifier. API endpoints for retrieving and potentially managing history are needed.

### **Guest User Features**

* **FR-42 (Guest Identity):** As a guest user, I want to use the tax assistant without signing up, while still maintaining persistent access to my conversation history on the same device.
* **FR-43 (System \- Guest Sessions):** The backend must generate and maintain secure guest session identifiers stored in browser storage (localStorage/cookies) to track unauthenticated users across visits.
* **FR-44 (Guest History):** As a guest user, I want the option to create an account and retain all my conversation history if I decide to register later.
* **FR-45 (System \- Identity Transition):** The backend must support migrating conversation history from a guest session to a registered user account when a user signs up.
* **FR-46 (Guest Limits):** As an operator, I want to set appropriate rate limits and feature restrictions for guest users to encourage registration while still providing value to casual users.
* **FR-47 (Device Syncing Notice):** As a guest user, I want to be informed that my conversation history is device-specific, with a suggestion to register for cross-device access.

### **Security Features**

* **FR-17 (Security \- Rate Limiting):** As an operator, I want API rate limiting implemented to prevent abuse and ensure fair usage.  
* **FR-18 (System \- Rate Limiting):** The backend must implement rate limiting (e.g., per user/IP) on API endpoints, particularly the LLM interaction endpoint. (e.g., using slowapi with Redis).  
* **FR-19 (Security \- WAF):** As an operator, I want the application protected by a Web Application Firewall (WAF) to block common web attacks (XSS, SQLi, etc.).  
* **FR-20 (System \- WAF):** The deployment architecture must include or integrate with a WAF service (e.g., Cloudflare, AWS WAF).  
* **FR-21 (Security \- Input Sanitization):** As an operator, I want robust input sanitization to prevent injection attacks targeting the application or the LLM.  
* **FR-22 (System \- Input Sanitization):** The backend must implement detailed input sanitization beyond basic validation, potentially using libraries like bleach or custom rules tailored to LLM interaction risks, before processing user input or sending it to an LLM.  
* **FR-23 (Security \- Captcha):** As an operator, I want Captcha protection on relevant forms (e.g., login, potentially query submission if unauthenticated) to prevent bot abuse.  
* **FR-24 (System \- Captcha):** The frontend must integrate a Captcha service (e.g., hCaptcha, Google reCAPTCHA). The backend must include verification logic for the Captcha response.

### **Operations & Monitoring**

* **FR-25 (Monitoring):** As an operator, I want real-time monitoring of application performance (request latency, error rates, resource utilization) and LLM API interactions (latency, error rates, token usage).  
* **FR-26 (System \- Monitoring):** The backend and potentially frontend must expose metrics in a format consumable by monitoring systems (e.g., Prometheus). Integrate with monitoring dashboards (e.g., Grafana, Datadog). Monitor LLM API performance and costs.  
* **FR-27 (Logging):** As an operator, I want detailed, structured logs for application events, errors, and key requests (including API calls, security events, user actions) aggregated in a central location.  
* **FR-28 (System \- Logging):** Implement structured logging (e.g., using structlog in Python) throughout the backend. Configure log shippers (e.g., Filebeat, Promtail) to send logs to an aggregation platform (e.g., ELK stack, Loki, Datadog Logs). Ensure appropriate log levels and information density.  
* **FR-29 (Alerting):** As an operator, I want to receive automated alerts for critical errors, performance degradation, security events, or anomalous LLM usage/costs.  
* **FR-30 (System \- Alerting):** Configure alerting rules based on metrics (e.g., via Prometheus Alertmanager) or logs. Integrate with notification channels (e.g., PagerDuty, Slack, Email).

### **User Experience Enhancements**

* **FR-31 (UI \- Suggested Questions):** As a user, I want to see a list of common tax-related questions I can click on to quickly get information.  
* **FR-32 (UI \- Follow-up Suggestions):** As a user, after receiving an answer, I want to see 3 relevant follow-up questions suggested by the AI to help guide the conversation or explore related topics.  
* **FR-33 (System \- Follow-up Suggestions):** The backend prompt engineering must instruct the LLM to generate relevant follow-up question suggestions based on the latest turn. The LLM response parsing must extract these suggestions. The API response model and frontend UI must accommodate displaying these suggestions.

### **System Requirements**

* **FR-34 (System):** The backend must perform enhanced input validation and sanitization on user messages.  
* **FR-35 (System):** The backend must securely load and manage API keys for multiple LLMs using environment variables or a secrets management system.  
* **FR-36 (System):** The backend must implement effective prompt engineering suitable for multi-turn conversations, including context management and instructions for generating follow-up questions.  
* **FR-37 (System):** The backend must handle communication with the selected LLM API, including request formatting and response parsing (including extracting follow-up suggestions).  
* **FR-38 (System):** The backend must gracefully handle errors from any supported LLM API and integrate error reporting with the logging/alerting systems.  
* **FR-39 (System):** The backend API response for a conversation turn must be structured (JSON) and include the answer text, token usage metadata, disclaimer information, and suggested follow-up questions.  
* **FR-40 (System):** The backend must configure CORS middleware.  
* **FR-41 (System):** The frontend must display user-friendly error messages, potentially with correlation IDs linking to backend logs for support.

## **4\. Non-Functional Requirements (NFRs)**

* **NFR-01: Performance**

  * Fast response times (\<1s UI response after submission)  
  * Efficient database queries for history retrieval  
  * Multiple LLM API latency considerations and potential fallbacks  
* **NFR-02: Security**

  * Authentication/authorization mechanisms  
  * Secure session management  
  * Database security  
  * Input validation and sanitization  
  * Protection against common web vulnerabilities  
* **NFR-03: Scalability**

  * Stateless backend design  
  * Database scaling strategies  
  * Redis scaling for rate limiting/caching  
  * Managing concurrent conversations  
* **NFR-04: Maintainability**

  * Modular code structure  
  * Comprehensive unit and integration testing  
  * Detailed code documentation  
  * Clear API documentation (e.g., Swagger)  
* **NFR-05: Design Patterns**

  * MVC-style organization for backend  
  * Atomic component structure for frontend  
  * State management patterns  
  * Multi-provider abstraction for LLMs  
  * Secure coding practices  
* **NFR-06: Cache Strategies**

  * Conversation state caching  
  * User session caching for both authenticated and guest users
  * Guest session identifier persistence in browser storage
  * Database query result caching  
  * Potential LLM response caching for common queries
* **NFR-07: Reliability**

  * High availability (\>99.9% uptime)  
  * Robust error handling  
  * Graceful degradation  
  * Failover mechanisms where appropriate  
* **NFR-08: Usability**

  * Intuitive conversational UI  
  * Clear tax information presentation  
  * Effective use of markdown formatting  
  * Mobile responsiveness  
  * Accessibility compliance  
* **NFR-09: Accessibility**

  * WCAG 2.1 AA compliance  
  * Screen reader compatibility  
  * Keyboard navigation  
  * Appropriate contrast ratios

## **5\. Design & UI/UX**

* **Layout:**

  * Conversational UI (chat interface)  
  * Clear distinction between user messages and AI responses  
  * Settings area for LLM selection  
  * Persistent disclaimer visibility  
* **Components:**

  * Input area (text area)  
  * Submit button  
  * Message bubbles with markdown rendering  
  * Conversation history panel  
  * Loading indicators  
  * Error messages  
  * Suggested questions list  
  * Follow-up question buttons/links  
  * LLM selection menu (optional)  
  * Guest user notification banner
  * Registration promotion for guest users
  * Device syncing limitations notice
* **Visual Design:**

  * Clean, professional aesthetic  
  * High readability for tax-related information  
  * Clear visual hierarchy for structured responses  
  * Consistent use of color and typography  
* **Frameworks:**

  * TailwindCSS  
  * Next.js/TypeScript (frontend)  
  * React component architecture  
* **Responsiveness & Accessibility:**

  * Mobile-first responsive design  
  * ARIA attributes for accessibility  
  * Keyboard navigation support  
  * Screen reader compatibility

## **6\. Prompt Engineering**

### **Base Template**

You are a helpful tax assistant for freelancers.  
The user will ask a tax-related question. Respond clearly and concisely.

Structure your response into:  
\- Applicable tax categories  
\- Deductible expenses (if relevant)  
\- Filing requirements and deadlines  
\- Exceptions or conditions

Use markdown formatting with bullet points, bold text for emphasis, and clear section headers.

After your answer, suggest 3 relevant follow-up questions the user might want to ask.

Always include the disclaimer: "This information is provided for general guidance only and does not constitute legal or financial advice. Consult with a qualified tax professional for advice specific to your situation."

## **7\. Technical Specifications Overview**

### **Backend Architecture**

#### **Framework & Core Technologies**

* **Python 3.11+** \- Selected for its rich ecosystem and strong ML/AI library support  
* **FastAPI** \- High-performance async framework with automatic OpenAPI documentation  
  * Dependency injection for service layers and configuration  
  * Pydantic for data validation and serialization  
  * Async request handling for optimal performance under load  
* **Uvicorn** \- ASGI server for production deployment  
* **Python Typing** \- Comprehensive type hints for improved code quality and IDE support

#### **Database Architecture**

* **Primary Storage: PostgreSQL 15+**

  * User profiles and authentication data  
  * Conversation history and metadata (both authenticated and guest)
  * Guest session management
  * SQLAlchemy 2.0 with async drivers for ORM  
  * Alembic for database migrations and versioning  
  * Database connection pooling for performance optimization
* **NoSQL: MongoDB**

  * Flexible storage for LLM conversation context  
  * Raw response data from LLMs  
  * Motor (async MongoDB driver) for non-blocking operations  
  * Document-based schema for flexible data storage

#### **Caching & Message Queuing**

* **Redis**

  * Rate limiting implementation  
  * Session state management  
  * Caching layer for frequently accessed data  
  * LLM response caching for common queries  
  * Pub/Sub for real-time notifications  
* **RabbitMQ**

  * Task queuing for asynchronous processing  
  * Background job handling for LLM interactions  
  * Retry mechanisms with dead letter exchanges  
  * Load leveling during traffic spikes

#### **LLM Integration**

* **Multi-Provider Abstraction Layer**

  * Factory pattern implementation for LLM service selection  
  * Unified interface for different LLM providers  
  * Fallback mechanisms when primary provider is unavailable  
  * Support for OpenAI, Anthropic, and Google models  
  * Custom prompt templates per provider optimization  
  * Token usage tracking and optimization  
* **Context Management**

  * Conversation state persistence  
  * Context windowing to maintain token limits  
  * Dynamic system prompts based on user settings

#### **Security Implementation**

* **Authentication**

  * JWT-based authentication flow  
  * OAuth 2.0 support for social login  
  * Token refresh mechanism  
  * Role-based access control
  * Guest session management with secure device identifiers
  * User conversion flow (guest to registered)
* **Input/Output Security**

  * Input validation with Pydantic models  
  * Input sanitization with bleach  
  * LLM prompt injection protection  
  * Custom security middlewares  
  * Content moderation for sensitive data  
* **API Security**

  * Rate limiting with sliding window algorithm  
  * Request throttling per user/IP  
  * CORS policy configuration  
  * API key management for third-party integrations  
  * Audit logging for security events

#### **Observability Stack**

* **Logging**

  * Structured logging with contextvars  
  * Log correlation with trace IDs  
  * Log levels configuration by environment  
  * Log rotation and retention policies  
* **Metrics**

  * Prometheus integration for metrics collection  
  * Custom metrics for LLM interactions  
  * Performance metrics for critical paths  
  * Business metrics for user engagement  
* **Monitoring**

  * Health check endpoints with detailed status  
  * Real-time dashboards with Grafana  
  * Latency histograms for performance tracking  
  * Custom alerting rules

### **Frontend Architecture**

#### **Framework & Core Technologies**

* **React 18+** \- For component-based UI with concurrent mode

  * Functional components with hooks architecture  
  * Custom hooks for reusable logic  
  * React Context for global state where appropriate  
  * Error boundaries for graceful failure handling  
* **Next.js 14+** \- For server-side rendering and API routes

  * App Router for improved routing  
  * Server components where appropriate  
  * API routes for backend proxy  
  * Image optimization  
* **TypeScript** \- For type safety and improved developer experience

  * Strict mode enabled  
  * Comprehensive type definitions  
  * Interface-based design  
  * Generic components for reusability

#### **State Management**

* **Application State**

  * Redux Toolkit for global state management  
  * RTK Query for data fetching and caching  
  * Immer for immutable state updates  
  * Redux persistence for offline capability
  * Guest session state management with localStorage/cookies  
* **Form Management**

  * React Hook Form for efficient form handling  
  * Zod for form validation schemas  
  * Controlled components for complex inputs

#### **UI Components & Styling**

* **Component Library**

  * Custom component library with atomic design principles  
  * Storybook documentation for component showcase  
  * Reusable layout components  
  * Accessibility-first component design  
* **Styling**

  * TailwindCSS for utility-first styling  
  * CSS variables for theming  
  * Responsive design breakpoints  
  * Dark/light mode support

#### **Client-Side Performance**

* **Optimization Techniques**

  * Code splitting by route  
  * Dynamic imports for heavy components  
  * Virtualized lists for long conversations  
  * Memoization of expensive components  
  * Web workers for heavy computations  
* **Caching Strategy**

  * SWR for data fetching with stale-while-revalidate  
  * Local storage for persistent user preferences  
  * Service worker for offline capabilities

#### **Testing Strategy**

* **Unit Testing**

  * React Testing Library for component testing  
  * Jest for utility functions  
  * Mock service worker for API mocking  
* **End-to-End Testing**

  * Cypress for critical user flows  
  * Playwright for cross-browser testing

### **DevOps & Deployment**

#### **Containerization**

* **Docker**  
  * Multi-stage builds for optimized images  
  * Separate development and production Dockerfiles  
  * Docker Compose for local development  
  * Container health checks  
  * Custom entrypoint scripts for initialization

#### **Orchestration**

* **Docker Swarm**  
  * Service definitions with scaling rules  
  * Rolling updates for zero-downtime deployment  
  * Secrets management for credentials  
  * Network isolation between services  
  * Volume management for persistent data

#### **CI/CD Pipeline**

* **GitHub Actions**  
  * Automated testing on pull requests  
  * Static code analysis with tools like mypy, eslint  
  * Security scanning with CodeQL  
  * Automated build and deployment process  
  * Environment-specific configuration

#### **Infrastructure**

* **Linux Server Configuration**

  * Hardened Ubuntu LTS base  
  * SSH key-only authentication  
  * UFW firewall configuration  
  * Fail2ban for SSH protection  
  * System resource monitoring  
* **Reverse Proxy & TLS**

  * Nginx reverse proxy configuration  
  * Let's Encrypt certificate automation  
  * HTTP/2 support  
  * Gzip compression  
  * Cache headers optimization

#### **Backup & Disaster Recovery**

* **Database Backups**

  * Automated daily backups  
  * Point-in-time recovery capability  
  * Cross-region backup storage  
  * Backup validation and testing  
* **Application Recovery**

  * Infrastructure as code with Terraform  
  * Documented restore procedures  
  * Regular recovery testing  
  * Backup environment for failover

## **8\. Implementation Details**

### **Backend Implementation Notes**

#### **FastAPI Application Structure**

backend/  
├── app/  
│   ├── api/  
│   │   ├── deps.py           \# Dependency injection  
│   │   ├── endpoints/  
│   │   │   ├── auth.py       \# Authentication endpoints  
│   │   │   ├── conversation.py  \# Conversation management  
│   │   │   ├── settings.py   \# User settings  
│   │   │   └── health.py     \# Health checks and metrics  
│   │   └── router.py         \# API router configuration  
│   ├── core/  
│   │   ├── config.py         \# Configuration management  
│   │   ├── security.py       \# Security utilities  
│   │   └── logging.py        \# Logging configuration  
│   ├── db/  
│   │   ├── session.py        \# Database session management  
│   │   └── models/           \# SQLAlchemy models  
│   ├── llm/  
│   │   ├── factory.py        \# LLM provider factory  
│   │   ├── base.py           \# Abstract base LLM class  
│   │   ├── openai.py         \# OpenAI implementation  
│   │   ├── claude.py         \# Anthropic implementation  
│   │   ├── gemini.py         \# Google implementation  
│   │   └── prompt\_templates/ \# Provider-specific templates  
│   ├── schemas/              \# Pydantic models  
│   ├── services/             \# Business logic  
│   │   ├── conversation.py   \# Conversation management  
│   │   ├── auth.py           \# Authentication service  
│   │   └── tax\_data.py       \# Tax information service  
│   └── utils/                \# Utility functions  
├── alembic/                  \# Database migrations  
├── tests/                    \# Test suite  
│   ├── conftest.py           \# Test fixtures  
│   ├── api/                  \# API tests  
│   ├── services/             \# Service tests  
│   └── llm/                  \# LLM integration tests  
├── Dockerfile                \# Production Docker image  
├── docker-compose.yml        \# Local development setup  
├── pyproject.toml            \# Dependencies and build config  
└── .env.example              \# Environment variables template

#### **Key Python Requirements**

\[tool.poetry.dependencies\]  
python \= "^3.11"  
fastapi \= "^0.110.0"  
uvicorn \= {extras \= \["standard"\], version \= "^0.27.0"}  
sqlalchemy \= "^2.0.27"  
asyncpg \= "^0.29.0"  
pydantic \= {extras \= \["email"\], version \= "^2.5.2"}  
alembic \= "^1.13.1"  
python-jose \= {extras \= \["cryptography"\], version \= "^3.3.0"}  
passlib \= {extras \= \["bcrypt"\], version \= "^1.7.4"}  
redis \= {extras \= \["hiredis"\], version \= "^5.0.1"}  
motor \= "^3.3.2"  
openai \= "^1.13.3"  
anthropic \= "^0.14.0"  
google-generativeai \= "^0.3.1"  
prometheus-fastapi-instrumentator \= "^6.1.0"  
structlog \= "^24.1.0"  
slowapi \= "^0.1.9"  
bleach \= "^6.1.0"  
aio-pika \= "^9.3.1"  \# RabbitMQ client

#### **FastAPI Route Implementation Example**

from fastapi import APIRouter, Depends, HTTPException, BackgroundTasks, Cookie, Request  
from sqlalchemy.ext.asyncio import AsyncSession  
from slowapi import Limiter  
from slowapi.util import get\_remote\_address
from typing import Optional
import uuid

from app.api.deps import get\_db, get\_current\_user_or_guest, get\_llm\_client  
from app.schemas.conversation import ConversationCreate, ConversationResponse  
from app.services.conversation import ConversationService  
from app.llm.base import BaseLLMClient  
from app.db.models.user import User
from app.core.security import create_guest_session

router \= APIRouter()  
limiter \= Limiter(key\_func=get\_remote\_address)

@router.post("/message", response\_model=ConversationResponse)  
@limiter.limit("10/minute")  
async def create\_message(  
    payload: ConversationCreate,  
    background\_tasks: BackgroundTasks,  
    request: Request,
    db: AsyncSession \= Depends(get\_db),  
    user_or_session: dict \= Depends(get\_current\_user_or_guest),  
    llm\_client: BaseLLMClient \= Depends(get\_llm\_client),
    guest_session_id: Optional[str] = Cookie(None)
):  
    """Process a new message in the conversation and get AI response"""  
    try:  
        service \= ConversationService(db, llm\_client)
        
        # Handle authenticated users vs guest sessions
        if user_or_session.get("type") == "authenticated":
            user_id = user_or_session["user"].id
            guest_id = None
            rate_limit = "20/minute"  # Higher limit for registered users
        else:
            user_id = None
            # Create a new guest session if needed
            if not guest_session_id:
                guest_session_id = create_guest_session(request)
            guest_id = guest_session_id
            rate_limit = "10/minute"  # Standard limit for guest users
        
        response \= await service.process\_message(  
            user\_id=user_id,  
            guest_id=guest_id,
            conversation\_id=payload.conversation\_id,  
            message=payload.message  
        )  
          
        # Track metrics and log interaction asynchronously  
        background\_tasks.add\_task(  
            service.track\_interaction,   
            user\_id=user_id,
            guest_id=guest_id,
            conversation\_id=response.conversation\_id,  
            tokens\_used=response.token\_usage  
        )  
          
        return response  
    except Exception as e:  
        # Log the exception with context  
        logger.exception(  
            "Error processing message",  
            user\_id=user_id if "user_id" in locals() else None,
            guest_id=guest_id if "guest_id" in locals() else None,
            conversation\_id=payload.conversation\_id,  
            error=str(e)  
        )  
        raise HTTPException(  
            status\_code=500,  
            detail="An error occurred while processing your message"  
        )

#### **LLM Service Implementation Example**

from abc import ABC, abstractmethod  
from typing import Dict, List, Optional, Union  
import structlog

logger \= structlog.get\_logger(\_\_name\_\_)

class BaseLLMClient(ABC):  
    """Abstract base class for LLM clients"""  
      
    @abstractmethod  
    async def generate\_response(  
        self,   
        message: str,   
        conversation\_history: List\[Dict\[str, str\]\],  
        \*\*kwargs  
    ) \-\> Dict\[str, Union\[str, int, List\[str\]\]\]:  
        """Generate a response from the LLM"""  
        pass

class OpenAIClient(BaseLLMClient):  
    """OpenAI implementation of LLM client"""  
      
    def \_\_init\_\_(self, api\_key: str, model: str \= "gpt-4o"):  
        from openai import AsyncOpenAI  
        self.client \= AsyncOpenAI(api\_key=api\_key)  
        self.model \= model  
          
    async def generate\_response(  
        self,   
        message: str,   
        conversation\_history: List\[Dict\[str, str\]\],  
        \*\*kwargs  
    ) \-\> Dict\[str, Union\[str, int, List\[str\]\]\]:  
        """Generate a response using OpenAI"""  
        try:  
            \# Format conversation history for OpenAI  
            messages \= self.\_format\_conversation\_history(conversation\_history)  
              
            \# Add system prompt  
            system\_prompt \= self.\_get\_system\_prompt()  
            messages.insert(0, {"role": "system", "content": system\_prompt})  
              
            \# Add user's message  
            messages.append({"role": "user", "content": message})  
              
            \# Call OpenAI API  
            response \= await self.client.chat.completions.create(  
                model=self.model,  
                messages=messages,  
                max\_tokens=1000,  
                temperature=0.7,  
                response\_format={"type": "json\_object"},  
                tools=\[  
                    {  
                        "type": "function",  
                        "function": {  
                            "name": "format\_tax\_response",  
                            "description": "Format a tax information response with follow-up questions",  
                            "parameters": {  
                                "type": "object",  
                                "properties": {  
                                    "answer": {  
                                        "type": "string",  
                                        "description": "The markdown-formatted tax advice"  
                                    },  
                                    "follow\_up\_questions": {  
                                        "type": "array",  
                                        "items": {"type": "string"},  
                                        "description": "3 suggested follow-up questions"  
                                    }  
                                },  
                                "required": \["answer", "follow\_up\_questions"\]  
                            }  
                        }  
                    }  
                \],  
                tool\_choice={"type": "function", "function": {"name": "format\_tax\_response"}}  
            )  
              
            \# Extract and format response  
            function\_call \= response.choices\[0\].message.tool\_calls\[0\].function  
            response\_data \= json.loads(function\_call.arguments)  
              
            return {  
                "answer": response\_data\["answer"\],  
                "follow\_up\_questions": response\_data\["follow\_up\_questions"\],  
                "token\_usage": {  
                    "prompt\_tokens": response.usage.prompt\_tokens,  
                    "completion\_tokens": response.usage.completion\_tokens,  
                    "total\_tokens": response.usage.total\_tokens  
                }  
            }  
        except Exception as e:  
            logger.exception("OpenAI API error", error=str(e))  
            raise  
      
    def \_format\_conversation\_history(self, history: List\[Dict\[str, str\]\]) \-\> List\[Dict\[str, str\]\]:  
        """Format conversation history for OpenAI API"""  
        formatted \= \[\]  
        for entry in history:  
            if entry\["role"\] \== "user":  
                formatted.append({"role": "user", "content": entry\["content"\]})  
            else:  
                formatted.append({"role": "assistant", "content": entry\["content"\]})  
        return formatted  
      
    def \_get\_system\_prompt(self) \-\> str:  
        """Get system prompt"""  
        base\_prompt \= """  
        You are a helpful tax assistant for freelancers.  
        The user will ask a tax-related question. Respond clearly and concisely.  
          
        Structure your response into:  
        \- Applicable tax categories  
        \- Deductible expenses (if relevant)  
        \- Filing requirements and deadlines  
        \- Exceptions or conditions  
          
        Use markdown formatting with bullet points, bold text for emphasis, and clear section headers.  
        After your answer, suggest 3 relevant follow-up questions the user might want to ask.  
          
        Always include the disclaimer: "This information is provided for general guidance only and does not constitute legal or financial advice. Consult with a qualified tax professional for advice specific to your situation."  
        """  
        
        return base\_prompt

#### **Database Models & Schema**

**Guest Session & User Management Schema:**

```python
# In app/db/models/session.py
class GuestSession(Base):
    __tablename__ = "guest_sessions"
    
    id = Column(String, primary_key=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    last_active = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    ip_address = Column(String, nullable=True)
    user_agent = Column(String, nullable=True)
    # Relationship with conversations
    conversations = relationship("Conversation", back_populates="guest_session")

# In app/db/models/conversation.py
class Conversation(Base):
    __tablename__ = "conversations"
    
    id = Column(UUID, primary_key=True, default=uuid.uuid4)
    # Can belong to authenticated user OR guest session
    user_id = Column(Integer, ForeignKey("users.id"), nullable=True)
    guest_session_id = Column(String, ForeignKey("guest_sessions.id"), nullable=True)
    # Ensure one or the other is set but not both
    __table_args__ = (
        CheckConstraint("(user_id IS NULL AND guest_session_id IS NOT NULL) OR (user_id IS NOT NULL AND guest_session_id IS NULL)"),
    )
    # Relationships
    user = relationship("User", back_populates="conversations")
    guest_session = relationship("GuestSession", back_populates="conversations")
    messages = relationship("Message", back_populates="conversation", cascade="all, delete-orphan")

# In app/db/models/message.py
class Message(Base):
    __tablename__ = "messages"
    
    id = Column(UUID, primary_key=True, default=uuid.uuid4)
    conversation_id = Column(UUID, ForeignKey("conversations.id"), nullable=False)
    role = Column(String, nullable=False)  # "user" or "assistant"
    content = Column(Text, nullable=False)
    created_at = Column(DateTime, default=datetime.utcnow)
    # LLM metadata
    llm_provider = Column(String, nullable=True)
    token_count = Column(Integer, nullable=True)
    # Relationships
    conversation = relationship("Conversation", back_populates="messages")

# In app/db/models/user.py
class User(Base):
    __tablename__ = "users"
    
    id = Column(Integer, primary_key=True)
    email = Column(String, unique=True, index=True)
    hashed_password = Column(String, nullable=False)
    created_at = Column(DateTime, default=datetime.utcnow)
    is_active = Column(Boolean, default=True)
    # Relationships
    conversations = relationship("Conversation", back_populates="user")
```

**Database Migration for Guest Sessions:**

The following Alembic migration will be generated to add the guest_sessions table and update the conversations table to support both user and guest associations:

```python
# In alembic/versions/xxxx_add_guest_sessions.py
def upgrade():
    # Create guest_sessions table
    op.create_table(
        "guest_sessions",
        sa.Column("id", sa.String(), primary_key=True),
        sa.Column("created_at", sa.DateTime(), nullable=False, default=sa.func.now()),
        sa.Column("last_active", sa.DateTime(), nullable=False, default=sa.func.now()),
        sa.Column("ip_address", sa.String(), nullable=True),
        sa.Column("user_agent", sa.String(), nullable=True),
    )
    
    # Add guest_session_id to conversations table
    op.add_column("conversations", sa.Column("guest_session_id", sa.String(), nullable=True))
    op.create_foreign_key(
        "fk_conversation_guest_session",
        "conversations", "guest_sessions",
        ["guest_session_id"], ["id"]
    )
    
    # Add check constraint to ensure either user_id or guest_session_id is set
    op.create_check_constraint(
        "ck_conversation_owner",
        "conversations",
        "(user_id IS NULL AND guest_session_id IS NOT NULL) OR (user_id IS NOT NULL AND guest_session_id IS NULL)"
    )

def downgrade():
    # Remove check constraint
    op.drop_constraint("ck_conversation_owner", "conversations")
    
    # Remove foreign key constraint and column
    op.drop_constraint("fk_conversation_guest_session", "conversations")
    op.drop_column("conversations", "guest_session_id")
    
    # Drop guest_sessions table
    op.drop_table("guest_sessions")
```

#### **Authentication & Session Management**

**Guest Session Management Utilities:**

```python
# In app/security/session.py
import secrets
import uuid
from datetime import datetime, timedelta
from fastapi import Request, Response
from app.db.models.session import GuestSession
from app.config import settings

GUEST_SESSION_COOKIE = "guest_session_id"
GUEST_SESSION_LENGTH = timedelta(days=30)  # Configurable session length

def generate_guest_session_id() -> str:
    """Generate a secure random session ID for guest users."""
    return secrets.token_urlsafe(32)

async def create_guest_session(db, request: Request) -> GuestSession:
    """Create a new guest session and store it in the database."""
    session_id = generate_guest_session_id()
    
    # Extract client information if available
    client_ip = request.client.host if request.client else None
    user_agent = request.headers.get("user-agent")
    
    # Create session record
    guest_session = GuestSession(
        id=session_id,
        ip_address=client_ip,
        user_agent=user_agent
    )
    
    db.add(guest_session)
    await db.commit()
    await db.refresh(guest_session)
    
    return guest_session

async def get_guest_session(db, request: Request) -> GuestSession:
    """Retrieve guest session from cookie or create a new one."""
    session_id = request.cookies.get(GUEST_SESSION_COOKIE)
    
    if session_id:
        # Try to fetch existing session
        guest_session = await db.query(GuestSession).filter(GuestSession.id == session_id).first()
        if guest_session:
            # Update last active timestamp
            guest_session.last_active = datetime.utcnow()
            await db.commit()
            return guest_session
    
    # Create new session if not found
    return await create_guest_session(db, request)

def set_guest_session_cookie(response: Response, session_id: str) -> None:
    """Set the guest session cookie on the response."""
    response.set_cookie(
        key=GUEST_SESSION_COOKIE,
        value=session_id,
        max_age=int(GUEST_SESSION_LENGTH.total_seconds()),
        httponly=True,
        secure=settings.COOKIE_SECURE,  # True in production
        samesite="lax"
    )
```

**Enhanced Authentication Dependencies:**

```python
# In app/dependencies/auth.py
from fastapi import Depends, HTTPException, status, Request, Response
from fastapi.security import OAuth2PasswordBearer
from sqlalchemy.ext.asyncio import AsyncSession
from app.db.session import get_db
from app.security.jwt import decode_access_token
from app.security.session import get_guest_session, set_guest_session_cookie
from app.db.models.user import User
from app.db.models.session import GuestSession

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token", auto_error=False)

async def get_current_user(
    token: str = Depends(oauth2_scheme),
    db: AsyncSession = Depends(get_db)
) -> User:
    """Get the current authenticated user or raise 401 error."""
    if not token:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Not authenticated",
            headers={"WWW-Authenticate": "Bearer"},
        )
    
    user_id = decode_access_token(token)
    if not user_id:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid authentication credentials",
            headers={"WWW-Authenticate": "Bearer"},
        )
    
    user = await db.query(User).filter(User.id == user_id).first()
    if not user:
        raise HTTPException(status_code=404, detail="User not found")
    
    return user

async def get_current_user_or_guest(
    request: Request,
    response: Response,
    token: str = Depends(oauth2_scheme),
    db: AsyncSession = Depends(get_db)
) -> tuple[User | None, GuestSession | None]:
    """
    Get either the current authenticated user or create/retrieve a guest session.
    Returns a tuple of (user, guest_session) where exactly one is None.
    """
    user = None
    guest_session = None
    
    # Try to get authenticated user first
    if token:
        user_id = decode_access_token(token)
        if user_id:
            user = await db.query(User).filter(User.id == user_id).first()
    
    # If no authenticated user, get or create guest session
    if not user:
        guest_session = await get_guest_session(db, request)
        set_guest_session_cookie(response, guest_session.id)
    
    return user, guest_session
```

#### **API Endpoints for Guest & User Sessions**

**Conversation API with Guest Support:**

```python
# In app/api/routes/conversations.py
from fastapi import APIRouter, Depends, HTTPException, Request, Response, status
from sqlalchemy.ext.asyncio import AsyncSession
from app.db.session import get_db
from app.dependencies.auth import get_current_user_or_guest
from app.services.conversation import ConversationService
from app.schemas.conversation import ConversationCreate, ConversationResponse, MessageCreate

router = APIRouter()

@router.post("/conversations/", response_model=ConversationResponse)
async def create_conversation(
    request: Request,
    response: Response,
    conversation_data: ConversationCreate,
    db: AsyncSession = Depends(get_db),
    auth: tuple = Depends(get_current_user_or_guest)
):
    """Create a new conversation for authenticated user or guest."""
    user, guest_session = auth
    
    conversation_service = ConversationService(db)
    
    if user:
        conversation = await conversation_service.create_conversation(
            title=conversation_data.title,
            user_id=user.id
        )
    else:
        conversation = await conversation_service.create_conversation(
            title=conversation_data.title,
            guest_session_id=guest_session.id
        )
    
    return conversation

@router.get("/conversations/", response_model=list[ConversationResponse])
async def get_conversations(
    request: Request,
    response: Response,
    db: AsyncSession = Depends(get_db),
    auth: tuple = Depends(get_current_user_or_guest)
):
    """Get all conversations for the current user or guest session."""
    user, guest_session = auth
    
    conversation_service = ConversationService(db)
    
    if user:
        conversations = await conversation_service.get_user_conversations(user.id)
    else:
        conversations = await conversation_service.get_guest_conversations(guest_session.id)
    
    return conversations
```

**Guest to User Conversion Endpoint:**

```python
# In app/api/routes/users.py
@router.post("/users/convert-guest/", response_model=UserResponse)
async def convert_guest_to_user(
    request: Request,
    response: Response,
    user_data: UserCreate,
    db: AsyncSession = Depends(get_db),
    auth: tuple = Depends(get_current_user_or_guest)
):
    """Convert a guest session to a registered user account."""
    user, guest_session = auth
    
    # If already authenticated, return error
    if user:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Already authenticated as a registered user"
        )
    
    if not guest_session:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="No guest session found"
        )
    
    # Create new user
    user_service = UserService(db)
    new_user = await user_service.create_user(user_data)
    
    # Transfer guest session conversations to new user
    conversation_service = ConversationService(db)
    await conversation_service.transfer_guest_conversations(
        guest_session_id=guest_session.id,
        user_id=new_user.id
    )
    
    # Clear guest session cookie
    response.delete_cookie(key=GUEST_SESSION_COOKIE)
    
    # Generate and return new access token
    token_data = {"sub": str(new_user.id)}
    access_token = create_access_token(data=token_data)
    
    return {"user": new_user, "access_token": access_token}
```

#### **Service Layer for Guest Users**

**Enhanced Conversation Service:**

```python
# In app/services/conversation.py
from sqlalchemy.ext.asyncio import AsyncSession
from app.db.models.conversation import Conversation
from app.db.models.message import Message

class ConversationService:
    def __init__(self, db: AsyncSession):
        self.db = db
    
    async def create_conversation(
        self, 
        title: str = "New Conversation", 
        user_id: int = None, 
        guest_session_id: str = None
    ) -> Conversation:
        """Create a conversation for either a user or a guest session."""
        if user_id is None and guest_session_id is None:
            raise ValueError("Either user_id or guest_session_id must be provided")
        
        if user_id is not None and guest_session_id is not None:
            raise ValueError("Only one of user_id or guest_session_id should be provided")
        
        conversation = Conversation(
            title=title,
            user_id=user_id,
            guest_session_id=guest_session_id
        )
        
        self.db.add(conversation)
        await self.db.commit()
        await self.db.refresh(conversation)
        
        return conversation
    
    async def get_user_conversations(self, user_id: int) -> list[Conversation]:
        """Get all conversations for a specific user."""
        conversations = await self.db.query(Conversation).filter(
            Conversation.user_id == user_id
        ).order_by(Conversation.created_at.desc()).all()
        
        return conversations
    
    async def get_guest_conversations(self, guest_session_id: str) -> list[Conversation]:
        """Get all conversations for a specific guest session."""
        conversations = await self.db.query(Conversation).filter(
            Conversation.guest_session_id == guest_session_id
        ).order_by(Conversation.created_at.desc()).all()
        
        return conversations
    
    async def transfer_guest_conversations(
        self, guest_session_id: str, user_id: int
    ) -> None:
        """Transfer all conversations from a guest session to a registered user."""
        conversations = await self.db.query(Conversation).filter(
            Conversation.guest_session_id == guest_session_id
        ).all()
        
        for conversation in conversations:
            conversation.user_id = user_id
            conversation.guest_session_id = None
        
        await self.db.commit()
```

### **Frontend Implementation Notes**

#### **Guest User Experience & Authentication Flow**

The frontend will provide a seamless experience for both guest and registered users, with an intuitive path to convert from guest to registered status.

**Authentication Context Provider:**

```typescript
// In src/contexts/AuthContext.tsx
import React, { createContext, useState, useEffect, useContext } from 'react';
import { User } from '../types/user';
import { api } from '../services/api';

interface AuthContextData {
  user: User | null;
  isGuest: boolean;
  isLoading: boolean;
  isAuthenticated: boolean;
  login: (email: string, password: string) => Promise<void>;
  logout: () => void;
  convertGuestToUser: (userData: UserCreateData) => Promise<void>;
}

const AuthContext = createContext<AuthContextData>({} as AuthContextData);

export const AuthProvider: React.FC = ({ children }) => {
  const [user, setUser] = useState<User | null>(null);
  const [isGuest, setIsGuest] = useState<boolean>(false);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    // Check for existing user session or guest cookie
    async function loadUserFromStorage() {
      setIsLoading(true);
      
      try {
        // Try to get user from token in localStorage
        const token = localStorage.getItem('@PawaIT:token');
        
        if (token) {
          api.defaults.headers.authorization = `Bearer ${token}`;
          const response = await api.get('/users/me');
          setUser(response.data);
          setIsGuest(false);
        } else {
          // No token, we're a guest - still need to fetch our guest ID from cookies
          // The cookie is httpOnly so we can't access it directly
          // Instead, we'll make a request that will use the cookie if present
          await api.get('/conversations'); // This will establish guest session if needed
          setIsGuest(true);
        }
      } catch (error) {
        // If token is invalid or expired, default to guest
        localStorage.removeItem('@PawaIT:token');
        setIsGuest(true);
      } finally {
        setIsLoading(false);
      }
    }
    
    loadUserFromStorage();
  }, []);

  const login = async (email: string, password: string) => {
    try {
      const response = await api.post('/token', { email, password });
      const { access_token, user } = response.data;
      
      localStorage.setItem('@PawaIT:token', access_token);
      api.defaults.headers.authorization = `Bearer ${access_token}`;
      
      setUser(user);
      setIsGuest(false);
    } catch (error) {
      throw error;
    }
  };
  
  const logout = () => {
    localStorage.removeItem('@PawaIT:token');
    delete api.defaults.headers.authorization;
    setUser(null);
    setIsGuest(true);
    // Note: guest session cookie persists so user can still access their guest data
  };
  
  const convertGuestToUser = async (userData: UserCreateData) => {
    try {
      const response = await api.post('/users/convert-guest', userData);
      const { access_token, user } = response.data;
      
      localStorage.setItem('@PawaIT:token', access_token);
      api.defaults.headers.authorization = `Bearer ${access_token}`;
      
      setUser(user);
      setIsGuest(false);
    } catch (error) {
      throw error;
    }
  };
  
  return (
    <AuthContext.Provider 
      value={{ 
        user, 
        isGuest, 
        isLoading, 
        isAuthenticated: !!user, 
        login, 
        logout,
        convertGuestToUser
      }}
    >
      {children}
    </AuthContext.Provider>
  );
};

export function useAuth(): AuthContextData {
  const context = useContext(AuthContext);
  return context;
}
```

**API Client Setup with Guest and User Support:**

```typescript
// In src/services/api.ts
import axios from 'axios';

const api = axios.create({
  baseURL: process.env.NEXT_PUBLIC_API_URL || 'http://localhost:8000',
  withCredentials: true, // Important for sending/receiving cookies
});

// Add interceptor to handle automatic session management
api.interceptors.response.use(
  response => response,
  error => {
    // Handle specific errors like 401 Unauthorized
    if (error.response && error.response.status === 401) {
      // If token is invalid but we have guest session cookie, still allow access
      const token = localStorage.getItem('@PawaIT:token');
      if (token) {
        // Clear token since it's invalid
        localStorage.removeItem('@PawaIT:token');
        delete api.defaults.headers.authorization;
        
        // Retry the request (without token, will use guest session)
        const originalRequest = error.config;
        delete originalRequest.headers.authorization;
        return axios(originalRequest);
      }
    }
    return Promise.reject(error);
  }
);

export { api };
```

**Guest to User Conversion UI Component:**

```typescript
// In src/components/GuestPrompt.tsx
import React, { useState } from 'react';
import { useAuth } from '../contexts/AuthContext';

export const GuestPrompt: React.FC = () => {
  const { isGuest, convertGuestToUser } = useAuth();
  const [isSignupModalOpen, setIsSignupModalOpen] = useState(false);
  const [formData, setFormData] = useState({
    name: '',
    email: '',
    password: '',
    confirmPassword: ''
  });
  const [errors, setErrors] = useState<Record<string, string>>({});
  const [isSubmitting, setIsSubmitting] = useState(false);
  
  if (!isGuest) return null; // Only show for guest users
  
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setIsSubmitting(true);
    
    // Basic validation
    const newErrors: Record<string, string> = {};
    if (!formData.name) newErrors.name = 'Name is required';
    if (!formData.email) newErrors.email = 'Email is required';
    if (!formData.password) newErrors.password = 'Password is required';
    if (formData.password !== formData.confirmPassword) {
      newErrors.confirmPassword = 'Passwords do not match';
    }
    
    if (Object.keys(newErrors).length > 0) {
      setErrors(newErrors);
      setIsSubmitting(false);
      return;
    }
    
    try {
      await convertGuestToUser({
        name: formData.name,
        email: formData.email,
        password: formData.password
      });
      setIsSignupModalOpen(false);
    } catch (error) {
      if (error.response?.data?.detail) {
        setErrors({ form: error.response.data.detail });
      } else {
        setErrors({ form: 'An error occurred. Please try again.' });
      }
    } finally {
      setIsSubmitting(false);
    }
  };
  
  return (
    <>
      <div className="guest-banner bg-yellow-100 p-2 text-center">
        <p className="text-sm">
          You're currently using PawaIT as a guest.{' '}
          <button 
            onClick={() => setIsSignupModalOpen(true)}
            className="text-blue-600 hover:underline"
          >
            Sign up
          </button>
          {' '}to save your chats and access more features!
        </p>
      </div>
      
      {/* Modal implementation for registration form */}
      {isSignupModalOpen && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
          <div className="bg-white p-6 rounded-lg w-full max-w-md">
            <h2 className="text-xl font-bold mb-4">Create Your Account</h2>
            <p className="mb-4 text-gray-600">
              Sign up to save your chat history and access premium features.
            </p>
            
            {errors.form && (
              <div className="bg-red-100 text-red-700 p-3 rounded mb-4">
                {errors.form}
              </div>
            )}
            
            <form onSubmit={handleSubmit}>
              {/* Form fields implementation */}
              <div className="mb-4">
                <label className="block text-gray-700 mb-1">Name</label>
                <input
                  type="text"
                  value={formData.name}
                  onChange={e => setFormData({...formData, name: e.target.value})}
                  className="w-full p-2 border rounded"
                />
                {errors.name && <p className="text-red-500 text-sm mt-1">{errors.name}</p>}
              </div>
              
              {/* Additional form fields... */}
              <div className="mb-4">
                <label className="block text-gray-700 mb-1">Email</label>
                <input
                  type="email"
                  value={formData.email}
                  onChange={e => setFormData({...formData, email: e.target.value})}
                  className="w-full p-2 border rounded"
                />
                {errors.email && <p className="text-red-500 text-sm mt-1">{errors.email}</p>}
              </div>
              
              <div className="mb-4">
                <label className="block text-gray-700 mb-1">Password</label>
                <input
                  type="password"
                  value={formData.password}
                  onChange={e => setFormData({...formData, password: e.target.value})}
                  className="w-full p-2 border rounded"
                />
                {errors.password && <p className="text-red-500 text-sm mt-1">{errors.password}</p>}
              </div>
              
              <div className="mb-6">
                <label className="block text-gray-700 mb-1">Confirm Password</label>
                <input
                  type="password"
                  value={formData.confirmPassword}
                  onChange={e => setFormData({...formData, confirmPassword: e.target.value})}
                  className="w-full p-2 border rounded"
                />
                {errors.confirmPassword && (
                  <p className="text-red-500 text-sm mt-1">{errors.confirmPassword}</p>
                )}
              </div>
              
              <div className="flex justify-end gap-2">
                <button
                  type="button"
                  onClick={() => setIsSignupModalOpen(false)}
                  className="px-4 py-2 text-gray-700 border rounded"
                >
                  Cancel
                </button>
                <button
                  type="submit"
                  disabled={isSubmitting}
                  className="px-4 py-2 bg-blue-600 text-white rounded disabled:bg-blue-400"
                >
                  {isSubmitting ? 'Creating Account...' : 'Create Account'}
                </button>
              </div>
            </form>
          </div>
        </div>
      )}
    </>
  );
};
```

#### **Data Models & Types for Guest Users**

```typescript
// In src/types/user.ts
export interface User {
  id: number;
  name: string;
  email: string;
  created_at: string;
}

export interface UserCreateData {
  name: string;
  email: string;
  password: string;
}

// In src/types/conversation.ts
export interface Conversation {
  id: number;
  title: string;
  created_at: string;
  updated_at: string;
  user_id: number | null;
  guest_session_id: string | null;
  messages: Message[];
}

export interface Message {
  id: number;
  content: string;
  is_from_user: boolean;
  created_at: string;
  conversation_id: number;
}

export interface ConversationCreateData {
  title: string;
}
```

### **Testing Requirements**

```pawait_prd.md
# **Product Requirements Document: Freelancer Tax Assistant (Production Spec)**

* **Version:** 2.1  
* **Date:** 2025-04-22  
* **Author:** Senior Software Engineer  
* **Status:** Draft

**Note:** This version incorporates requirements for production-grade features, significantly expanding the scope beyond the original assessment prototype. Development time and effort will be substantially higher.

## **1\. Introduction**

This document outlines the requirements for the "Freelancer Tax Assistant," a modern, conversational web application targeting freelancers. Users can engage in multi-turn conversations about tax-related questions, receiving informative, structured answers generated by selectable Large Language Models (LLMs). The application prioritizes security, reliability, and user experience, incorporating production-grade monitoring, logging, alerting, and persistent user history. The system supports both authenticated users with cross-device access and guest users with device-specific history, ensuring a seamless experience regardless of authentication status.

## **2\. Goals & Objectives**

* **Primary:** Deliver a secure, scalable, and reliable conversational AI application providing accurate tax information for freelancers.  
* **User Engagement:** Enable multi-turn conversations, allowing users to ask follow-up questions and refine their queries naturally.  
* **Accessibility:** Remove barriers to entry by allowing immediate use without registration while still providing persistent history.
* **Flexibility:** Support multiple underlying LLMs, allowing for potential selection based on user preference or performance characteristics.  
* **Reliability & Ops:** Implement comprehensive monitoring, logging, and alerting to ensure high availability and facilitate prompt issue resolution in a production environment.  
* **Security:** Integrate robust security measures to protect the application and its users from common threats.  
* **Persistence:** Provide users with persistent access to their query history across sessions.

## **3\. Functional Requirements (User Stories)**

### **Basic Interaction**

* **FR-01:** As a user, I want to access the web application via a standard web browser on both desktop and mobile devices.  
* **FR-02:** As a user, I want to see a clear text input area where I can type my tax-related question.  
* **FR-03:** As a user, I want to submit my message by clicking a button or pressing Enter.  
* **FR-04:** As a user, I want to see a visual indicator (e.g., loading spinner) while the application is processing my message.  
* **FR-05:** As a user, I want the AI-generated response to be displayed clearly in a conversational format with proper markdown formatting (bullets, sections, bold highlights).  
* **FR-06:** As a user, I want to see information about the LLM token usage for each turn of the conversation.  
* **FR-07:** As a user, I want to always see a disclaimer indicating that responses are not legal or financial advice.  
* **FR-08 (System):** The backend API must expose endpoints to manage conversational interactions.

### **Multi-Turn Conversation**

* **FR-11 (Multi-Turn):** As a user, I want the AI to remember the context of our current conversation, so I can ask follow-up questions without repeating previous information.  
* **FR-12 (System \- Multi-Turn):** The backend must manage conversation state (context) across multiple requests within a user session. This context must be passed to the LLM API on subsequent turns.

### **LLM Selection**

* **FR-13 (LLM Selection):** As a user, I want to optionally select which underlying LLM (e.g., Gemini, ChatGPT, Claude) powers the conversation, perhaps via a settings menu. (Default can be pre-set).  
* **FR-14 (System \- LLM Selection):** The backend must include an abstraction layer to interact with multiple different LLM APIs. API keys and configurations for all supported LLMs must be securely managed. The API must handle requests to use a specific LLM for a given conversation or user setting.

### **Persistent History**

* **FR-15 (Persistent History):** As a user (authenticated or guest), I want my conversation history to be saved automatically and persistently, so I can access it again from the same device or across devices (if authenticated).  
* **FR-16 (System \- Persistent History):** The backend must securely store user conversation history (queries, responses, context, timestamps) in a persistent database (e.g., PostgreSQL, MongoDB). For authenticated users, conversations are linked to user accounts. For guest users, conversations are linked to a secure device identifier. API endpoints for retrieving and potentially managing history are needed.

### **Guest User Features**

* **FR-42 (Guest Identity):** As a guest user, I want to use the tax assistant without signing up, while still maintaining persistent access to my conversation history on the same device.
* **FR-43 (System \- Guest Sessions):** The backend must generate and maintain secure guest session identifiers stored in browser storage (localStorage/cookies) to track unauthenticated users across visits.
* **FR-44 (Guest History):** As a guest user, I want the option to create an account and retain all my conversation history if I decide to register later.
* **FR-45 (System \- Identity Transition):** The backend must support migrating conversation history from a guest session to a registered user account when a user signs up.
* **FR-46 (Guest Limits):** As an operator, I want to set appropriate rate limits and feature restrictions for guest users to encourage registration while still providing value to casual users.
* **FR-47 (Device Syncing Notice):** As a guest user, I want to be informed that my conversation history is device-specific, with a suggestion to register for cross-device access.

### **Security Features**

* **FR-17 (Security \- Rate Limiting):** As an operator, I want API rate limiting implemented to prevent abuse and ensure fair usage.  
* **FR-18 (System \- Rate Limiting):** The backend must implement rate limiting (e.g., per user/IP) on API endpoints, particularly the LLM interaction endpoint. (e.g., using slowapi with Redis).  
* **FR-19 (Security \- WAF):** As an operator, I want the application protected by a Web Application Firewall (WAF) to block common web attacks (XSS, SQLi, etc.).  
* **FR-20 (System \- WAF):** The deployment architecture must include or integrate with a WAF service (e.g., Cloudflare, AWS WAF).  
* **FR-21 (Security \- Input Sanitization):** As an operator, I want robust input sanitization to prevent injection attacks targeting the application or the LLM.  
* **FR-22 (System \- Input Sanitization):** The backend must implement detailed input sanitization beyond basic validation, potentially using libraries like bleach or custom rules tailored to LLM interaction risks, before processing user input or sending it to an LLM.  
* **FR-23 (Security \- Captcha):** As an operator, I want Captcha protection on relevant forms (e.g., login, potentially query submission if unauthenticated) to prevent bot abuse.  
* **FR-24 (System \- Captcha):** The frontend must integrate a Captcha service (e.g., hCaptcha, Google reCAPTCHA). The backend must include verification logic for the Captcha response.

### **Operations & Monitoring**

* **FR-25 (Monitoring):** As an operator, I want real-time monitoring of application performance (request latency, error rates, resource utilization) and LLM API interactions (latency, error rates, token usage).  
* **FR-26 (System \- Monitoring):** The backend and potentially frontend must expose metrics in a format consumable by monitoring systems (e.g., Prometheus). Integrate with monitoring dashboards (e.g., Grafana, Datadog). Monitor LLM API performance and costs.  
* **FR-27 (Logging):** As an operator, I want detailed, structured logs for application events, errors, and key requests (including API calls, security events, user actions) aggregated in a central location.  
* **FR-28 (System \- Logging):** Implement structured logging (e.g., using structlog in Python) throughout the backend. Configure log shippers (e.g., Filebeat, Promtail) to send logs to an aggregation platform (e.g., ELK stack, Loki, Datadog Logs). Ensure appropriate log levels and information density.  
* **FR-29 (Alerting):** As an operator, I want to receive automated alerts for critical errors, performance degradation, security events, or anomalous LLM usage/costs.  
* **FR-30 (System \- Alerting):** Configure alerting rules based on metrics (e.g., via Prometheus Alertmanager) or logs. Integrate with notification channels (e.g., PagerDuty, Slack, Email).

### **User Experience Enhancements**

* **FR-31 (UI \- Suggested Questions):** As a user, I want to see a list of common tax-related questions I can click on to quickly get information.  
* **FR-32 (UI \- Follow-up Suggestions):** As a user, after receiving an answer, I want to see 3 relevant follow-up questions suggested by the AI to help guide the conversation or explore related topics.  
* **FR-33 (System \- Follow-up Suggestions):** The backend prompt engineering must instruct the LLM to generate relevant follow-up question suggestions based on the latest turn. The LLM response parsing must extract these suggestions. The API response model and frontend UI must accommodate displaying these suggestions.

### **System Requirements**

* **FR-34 (System):** The backend must perform enhanced input validation and sanitization on user messages.  
* **FR-35 (System):** The backend must securely load and manage API keys for multiple LLMs using environment variables or a secrets management system.  
* **FR-36 (System):** The backend must implement effective prompt engineering suitable for multi-turn conversations, including context management and instructions for generating follow-up questions.  
* **FR-37 (System):** The backend must handle communication with the selected LLM API, including request formatting and response parsing (including extracting follow-up suggestions).  
* **FR-38 (System):** The backend must gracefully handle errors from any supported LLM API and integrate error reporting with the logging/alerting systems.  
* **FR-39 (System):** The backend API response for a conversation turn must be structured (JSON) and include the answer text, token usage metadata, disclaimer information, and suggested follow-up questions.  
* **FR-40 (System):** The backend must configure CORS middleware.  
* **FR-41 (System):** The frontend must display user-friendly error messages, potentially with correlation IDs linking to backend logs for support.

## **4\. Non-Functional Requirements (NFRs)**

* **NFR-01: Performance**

  * Fast response times (\<1s UI response after submission)  
  * Efficient database queries for history retrieval  
  * Multiple LLM API latency considerations and potential fallbacks  
* **NFR-02: Security**

  * Authentication/authorization mechanisms  
  * Secure session management  
  * Database security  
  * Input validation and sanitization  
  * Protection against common web vulnerabilities  
* **NFR-03: Scalability**

  * Stateless backend design  
  * Database scaling strategies  
  * Redis scaling for rate limiting/caching  
  * Managing concurrent conversations  
* **NFR-04: Maintainability**

  * Modular code structure  
  * Comprehensive unit and integration testing  
  * Detailed code documentation  
  * Clear API documentation (e.g., Swagger)  
* **NFR-05: Design Patterns**

  * MVC-style organization for backend  
  * Atomic component structure for frontend  
  * State management patterns  
  * Multi-provider abstraction for LLMs  
  * Secure coding practices  
* **NFR-06: Cache Strategies**

  * Conversation state caching  
  * User session caching for both authenticated and guest users
  * Guest session identifier persistence in browser storage
  * Database query result caching  
  * Potential LLM response caching for common queries
* **NFR-07: Reliability**

  * High availability (\>99.9% uptime)  
  * Robust error handling  
  * Graceful degradation  
  * Failover mechanisms where appropriate  
* **NFR-08: Usability**

  * Intuitive conversational UI  
  * Clear tax information presentation  
  * Effective use of markdown formatting  
  * Mobile responsiveness  
  * Accessibility compliance  
* **NFR-09: Accessibility**

  * WCAG 2.1 AA compliance  
  * Screen reader compatibility  
  * Keyboard navigation  
  * Appropriate contrast ratios

## **5\. Design & UI/UX**

* **Layout:**

  * Conversational UI (chat interface)  
  * Clear distinction between user messages and AI responses  
  * Settings area for LLM selection  
  * Persistent disclaimer visibility  
* **Components:**

  * Input area (text area)  
  * Submit button  
  * Message bubbles with markdown rendering  
  * Conversation history panel  
  * Loading indicators  
  * Error messages  
  * Suggested questions list  
  * Follow-up question buttons/links  
  * LLM selection menu (optional)  
  * Guest user notification banner
  * Registration promotion for guest users
  * Device syncing limitations notice
* **Visual Design:**

  * Clean, professional aesthetic  
  * High readability for tax-related information  
  * Clear visual hierarchy for structured responses  
  * Consistent use of color and typography  
* **Frameworks:**

  * TailwindCSS  
  * Next.js/TypeScript (frontend)  
  * React component architecture  
* **Responsiveness & Accessibility:**

  * Mobile-first responsive design  
  * ARIA attributes for accessibility  
  * Keyboard navigation support  
  * Screen reader compatibility

## **6\. Prompt Engineering**

### **Base Template**

You are a helpful tax assistant for freelancers.  
The user will ask a tax-related question. Respond clearly and concisely.

Structure your response into:  
\- Applicable tax categories  
\- Deductible expenses (if relevant)  
\- Filing requirements and deadlines  
\- Exceptions or conditions

Use markdown formatting with bullet points, bold text for emphasis, and clear section headers.

After your answer, suggest 3 relevant follow-up questions the user might want to ask.

Always include the disclaimer: "This information is provided for general guidance only and does not constitute legal or financial advice. Consult with a qualified tax professional for advice specific to your situation."

## **7\. Technical Specifications Overview**

### **Backend Architecture**

#### **Framework & Core Technologies**

* **Python 3.11+** \- Selected for its rich ecosystem and strong ML/AI library support  
* **FastAPI** \- High-performance async framework with automatic OpenAPI documentation  
  * Dependency injection for service layers and configuration  
  * Pydantic for data validation and serialization  
  * Async request handling for optimal performance under load  
* **Uvicorn** \- ASGI server for production deployment  
* **Python Typing** \- Comprehensive type hints for improved code quality and IDE support

#### **Database Architecture**

* **Primary Storage: PostgreSQL 15+**

  * User profiles and authentication data  
  * Conversation history and metadata (both authenticated and guest)
  * Guest session management
  * SQLAlchemy 2.0 with async drivers for ORM  
  * Alembic for database migrations and versioning  
  * Database connection pooling for performance optimization
* **NoSQL: MongoDB**

  * Flexible storage for LLM conversation context  
  * Raw response data from LLMs  
  * Motor (async MongoDB driver) for non-blocking operations  
  * Document-based schema for flexible data storage

#### **Caching & Message Queuing**

* **Redis**

  * Rate limiting implementation  
  * Session state management  
  * Caching layer for frequently accessed data  
  * LLM response caching for common queries  
  * Pub/Sub for real-time notifications  
* **RabbitMQ**

  * Task queuing for asynchronous processing  
  * Background job handling for LLM interactions  
  * Retry mechanisms with dead letter exchanges  
  * Load leveling during traffic spikes

#### **LLM Integration**

* **Multi-Provider Abstraction Layer**

  * Factory pattern implementation for LLM service selection  
  * Unified interface for different LLM providers  
  * Fallback mechanisms when primary provider is unavailable  
  * Support for OpenAI, Anthropic, and Google models  
  * Custom prompt templates per provider optimization  
  * Token usage tracking and optimization  
* **Context Management**

  * Conversation state persistence  
  * Context windowing to maintain token limits  
  * Dynamic system prompts based on user settings

#### **Security Implementation**

* **Authentication**

  * JWT-based authentication flow  
  * OAuth 2.0 support for social login  
  * Token refresh mechanism  
  * Role-based access control
  * Guest session management with secure device identifiers
  * User conversion flow (guest to registered)
* **Input/Output Security**

  * Input validation with Pydantic models  
  * Input sanitization with bleach  
  * LLM prompt injection protection  
  * Custom security middlewares  
  * Content moderation for sensitive data  
* **API Security**

  * Rate limiting with sliding window algorithm  
  * Request throttling per user/IP  
  * CORS policy configuration  
  * API key management for third-party integrations  
  * Audit logging for security events

#### **Observability Stack**

* **Logging**

  * Structured logging with contextvars  
  * Log correlation with trace IDs  
  * Log levels configuration by environment  
  * Log rotation and retention policies  
* **Metrics**

  * Prometheus integration for metrics collection  
  * Custom metrics for LLM interactions  
  * Performance metrics for critical paths  
  * Business metrics for user engagement  
* **Monitoring**

  * Health check endpoints with detailed status  
  * Real-time dashboards with Grafana  
  * Latency histograms for performance tracking  
  * Custom alerting rules

### **Frontend Architecture**

#### **Framework & Core Technologies**

* **React 18+** \- For component-based UI with concurrent mode

  * Functional components with hooks architecture  
  * Custom hooks for reusable logic  
  * React Context for global state where appropriate  
  * Error boundaries for graceful failure handling  
* **Next.js 14+** \- For server-side rendering and API routes

  * App Router for improved routing  
  * Server components where appropriate  
  * API routes for backend proxy  
  * Image optimization  
* **TypeScript** \- For type safety and improved developer experience

  * Strict mode enabled  
  * Comprehensive type definitions  
  * Interface-based design  
  * Generic components for reusability

#### **State Management**

* **Application State**

  * Redux Toolkit for global state management  
  * RTK Query for data fetching and caching  
  * Immer for immutable state updates  
  * Redux persistence for offline capability
  * Guest session state management with localStorage/cookies  
* **Form Management**

  * React Hook Form for efficient form handling  
  * Zod for form validation schemas  
  * Controlled components for complex inputs

#### **UI Components & Styling**

* **Component Library**

  * Custom component library with atomic design principles  
  * Storybook documentation for component showcase  
  * Reusable layout components  
  * Accessibility-first component design  
* **Styling**

  * TailwindCSS for utility-first styling  
  * CSS variables for theming  
  * Responsive design breakpoints  
  * Dark/light mode support

#### **Client-Side Performance**

* **Optimization Techniques**

  * Code splitting by route  
  * Dynamic imports for heavy components  
  * Virtualized lists for long conversations  
  * Memoization of expensive components  
  * Web workers for heavy computations  
* **Caching Strategy**

  * SWR for data fetching with stale-while-revalidate  
  * Local storage for persistent user preferences  
  * Service worker for offline capabilities

#### **Testing Strategy**

* **Unit Testing**

  * React Testing Library for component testing  
  * Jest for utility functions  
  * Mock service worker for API mocking  
* **End-to-End Testing**

  * Cypress for critical user flows  
  * Playwright for cross-browser testing

### **DevOps & Deployment**

#### **Containerization**

* **Docker**  
  * Multi-stage builds for optimized images  
  * Separate development and production Dockerfiles  
  * Docker Compose for local development  
  * Container health checks  
  * Custom entrypoint scripts for initialization

#### **Orchestration**

* **Docker Swarm**  
  * Service definitions with scaling rules  
  * Rolling updates for zero-downtime deployment  
  * Secrets management for credentials  
  * Network isolation between services  
  * Volume management for persistent data

#### **CI/CD Pipeline**

* **GitHub Actions**  
  * Automated testing on pull requests  
  * Static code analysis with tools like mypy, eslint  
  * Security scanning with CodeQL  
  * Automated build and deployment process  
  * Environment-specific configuration

#### **Infrastructure**

* **Linux Server Configuration**

  * Hardened Ubuntu LTS base  
  * SSH key-only authentication  
  * UFW firewall configuration  
  * Fail2ban for SSH protection  
  * System resource monitoring  
* **Reverse Proxy & TLS**

  * Nginx reverse proxy configuration  
  * Let's Encrypt certificate automation  
  * HTTP/2 support  
  * Gzip compression  
  * Cache headers optimization

#### **Backup & Disaster Recovery**

* **Database Backups**

  * Automated daily backups  
  * Point-in-time recovery capability  
  * Cross-region backup storage  
  * Backup validation and testing  
* **Application Recovery**

  * Infrastructure as code with Terraform  
  * Documented restore procedures  
  * Regular recovery testing  
  * Backup environment for failover

## **8\. Implementation Details**

### **Backend Implementation Notes**

#### **FastAPI Application Structure**

backend/  
├── app/  
│   ├── api/  
│   │   ├── deps.py           \# Dependency injection  
│   │   ├── endpoints/  
│   │   │   ├── auth.py       \# Authentication endpoints  
│   │   │   ├── conversation.py  \# Conversation management  
│   │   │   ├── settings.py   \# User settings  
│   │   │   └── health.py     \# Health checks and metrics  
│   │   └── router.py         \# API router configuration  
│   ├── core/  
│   │   ├── config.py         \# Configuration management  
│   │   ├── security.py       \# Security utilities  
│   │   └── logging.py        \# Logging configuration  
│   ├── db/  
│   │   ├── session.py        \# Database session management  
│   │   └── models/           \# SQLAlchemy models  
│   ├── llm/  
│   │   ├── factory.py        \# LLM provider factory  
│   │   ├── base.py           \# Abstract base LLM class  
│   │   ├── openai.py         \# OpenAI implementation  
│   │   ├── claude.py         \# Anthropic implementation  
│   │   ├── gemini.py         \# Google implementation  
│   │   └── prompt\_templates/ \# Provider-specific templates  
│   ├── schemas/              \# Pydantic models  
│   ├── services/             \# Business logic  
│   │   ├── conversation.py   \# Conversation management  
│   │   ├── auth.py           \# Authentication service  
│   │   └── tax\_data.py       \# Tax information service  
│   └── utils/                \# Utility functions  
├── alembic/                  \# Database migrations  
├── tests/                    \# Test suite  
│   ├── conftest.py           \# Test fixtures  
│   ├── api/                  \# API tests  
│   ├── services/             \# Service tests  
│   └── llm/                  \# LLM integration tests  
├── Dockerfile                \# Production Docker image  
├── docker-compose.yml        \# Local development setup  
├── pyproject.toml            \# Dependencies and build config  
└── .env.example              \# Environment variables template

#### **Key Python Requirements**

\[tool.poetry.dependencies\]  
python \= "^3.11"  
fastapi \= "^0.110.0"  
uvicorn \= {extras \= \["standard"\], version \= "^0.27.0"}  
sqlalchemy \= "^2.0.27"  
asyncpg \= "^0.29.0"  
pydantic \= {extras \= \["email"\], version \= "^2.5.2"}  
alembic \= "^1.13.1"  
python-jose \= {extras \= \["cryptography"\], version \= "^3.3.0"}  
passlib \= {extras \= \["bcrypt"\], version \= "^1.7.4"}  
redis \= {extras \= \["hiredis"\], version \= "^5.0.1"}  
motor \= "^3.3.2"  
openai \= "^1.13.3"  
anthropic \= "^0.14.0"  
google-generativeai \= "^0.3.1"  
prometheus-fastapi-instrumentator \= "^6.1.0"  
structlog \= "^24.1.0"  
slowapi \= "^0.1.9"  
bleach \= "^6.1.0"  
aio-pika \= "^9.3.1"  \# RabbitMQ client

#### **FastAPI Route Implementation Example**

from fastapi import APIRouter, Depends, HTTPException, BackgroundTasks, Cookie, Request  
from sqlalchemy.ext.asyncio import AsyncSession  
from slowapi import Limiter  
from slowapi.util import get\_remote\_address
from typing import Optional
import uuid

from app.api.deps import get\_db, get\_current\_user_or_guest, get\_llm\_client  
from app.schemas.conversation import ConversationCreate, ConversationResponse  
from app.services.conversation import ConversationService  
from app.llm.base import BaseLLMClient  
from app.db.models.user import User
from app.core.security import create_guest_session

router \= APIRouter()  
limiter \= Limiter(key\_func=get\_remote\_address)

@router.post("/message", response\_model=ConversationResponse)  
@limiter.limit("10/minute")  
async def create\_message(  
    payload: ConversationCreate,  
    background\_tasks: BackgroundTasks,  
    request: Request,
    db: AsyncSession \= Depends(get\_db),  
    user_or_session: dict \= Depends(get\_current\_user_or_guest),  
    llm\_client: BaseLLMClient \= Depends(get\_llm\_client),
    guest_session_id: Optional[str] = Cookie(None)
):  
    """Process a new message in the conversation and get AI response"""  
    try:  
        service \= ConversationService(db, llm\_client)
        
        # Handle authenticated users vs guest sessions
        if user_or_session.get("type") == "authenticated":
            user_id = user_or_session["user"].id
            guest_id = None
            rate_limit = "20/minute"  # Higher limit for registered users
        else:
            user_id = None
            # Create a new guest session if needed
            if not guest_session_id:
                guest_session_id = create_guest_session(request)
            guest_id = guest_session_id
            rate_limit = "10/minute"  # Standard limit for guest users
        
        response \= await service.process\_message(  
            user\_id=user_id,  
            guest_id=guest_id,
            conversation\_id=payload.conversation\_id,  
            message=payload.message  
        )  
          
        # Track metrics and log interaction asynchronously  
        background\_tasks.add\_task(  
            service.track\_interaction,   
            user\_id=user_id,
            guest_id=guest_id,
            conversation\_id=response.conversation\_id,  
            tokens\_used=response.token\_usage  
        )  
          
        return response  
    except Exception as e:  
        # Log the exception with context  
        logger.exception(  
            "Error processing message",  
            user\_id=user_id if "user_id" in locals() else None,
            guest_id=guest_id if "guest_id" in locals() else None,
            conversation\_id=payload.conversation\_id,  
            error=str(e)  
        )  
        raise HTTPException(  
            status\_code=500,  
            detail="An error occurred while processing your message"  
        )

#### **LLM Service Implementation Example**

from abc import ABC, abstractmethod  
from typing import Dict, List, Optional, Union  
import structlog

logger \= structlog.get\_logger(\_\_name\_\_)

class BaseLLMClient(ABC):  
    """Abstract base class for LLM clients"""  
      
    @abstractmethod  
    async def generate\_response(  
        self,   
        message: str,   
        conversation\_history: List\[Dict\[str, str\]\],  
        \*\*kwargs  
    ) \-\> Dict\[str, Union\[str, int, List\[str\]\]\]:  
        """Generate a response from the LLM"""  
        pass

class OpenAIClient(BaseLLMClient):  
    """OpenAI implementation of LLM client"""  
      
    def \_\_init\_\_(self, api\_key: str, model: str \= "gpt-4o"):  
        from openai import AsyncOpenAI  
        self.client \= AsyncOpenAI(api\_key=api\_key)  
        self.model \= model  
          
    async def generate\_response(  
        self,   
        message: str,   
        conversation\_history: List\[Dict\[str, str\]\],  
        \*\*kwargs  
    ) \-\> Dict\[str, Union\[str, int, List\[str\]\]\]:  
        """Generate a response using OpenAI"""  
        try:  
            \# Format conversation history for OpenAI  
            messages \= self.\_format\_conversation\_history(conversation\_history)  
              
            \# Add system prompt  
            system\_prompt \= self.\_get\_system\_prompt()  
            messages.insert(0, {"role": "system", "content": system\_prompt})  
              
            \# Add user's message  
            messages.append({"role": "user", "content": message})  
              
            \# Call OpenAI API  
            response \= await self.client.chat.completions.create(  
                model=self.model,  
                messages=messages,  
                max\_tokens=1000,  
                temperature=0.7,  
                response\_format={"type": "json\_object"},  
                tools=\[  
                    {  
                        "type": "function",  
                        "function": {  
                            "name": "format\_tax\_response",  
                            "description": "Format a tax information response with follow-up questions",  
                            "parameters": {  
                                "type": "object",  
                                "properties": {  
                                    "answer": {  
                                        "type": "string",  
                                        "description": "The markdown-formatted tax advice"  
                                    },  
                                    "follow\_up\_questions": {  
                                        "type": "array",  
                                        "items": {"type": "string"},  
                                        "description": "3 suggested follow-up questions"  
                                    }  
                                },  
                                "required": \["answer", "follow\_up\_questions"\]  
                            }  
                        }  
                    }  
                \],  
                tool\_choice={"type": "function", "function": {"name": "format\_tax\_response"}}  
            )  
              
            \# Extract and format response  
            function\_call \= response.choices\[0\].message.tool\_calls\[0\].function  
            response\_data \= json.loads(function\_call.arguments)  
              
            return {  
                "answer": response\_data\["answer"\],  
                "follow\_up\_questions": response\_data\["follow\_up\_questions"\],  
                "token\_usage": {  
                    "prompt\_tokens": response.usage.prompt\_tokens,  
                    "completion\_tokens": response.usage.completion\_tokens,  
                    "total\_tokens": response.usage.total\_tokens  
                }  
            }  
        except Exception as e:  
            logger.exception("OpenAI API error", error=str(e))  
            raise  
      
    def \_format\_conversation\_history(self, history: List\[Dict\[str, str\]\]) \-\> List\[Dict\[str, str\]\]:  
        """Format conversation history for OpenAI API"""  
        formatted \= \[\]  
        for entry in history:  
            if entry\["role"\] \== "user":  
                formatted.append({"role": "user", "content": entry\["content"\]})  
            else:  
                formatted.append({"role": "assistant", "content": entry\["content"\]})  
        return formatted  
      
    def \_get\_system\_prompt(self) \-\> str:  
        """Get system prompt"""  
        base\_prompt \= """  
        You are a helpful tax assistant for freelancers.  
        The user will ask a tax-related question. Respond clearly and concisely.  
          
        Structure your response into:  
        \- Applicable tax categories  
        \- Deductible expenses (if relevant)  
        \- Filing requirements and deadlines  
        \- Exceptions or conditions  
          
        Use markdown formatting with bullet points, bold text for emphasis, and clear section headers.  
        After your answer, suggest 3 relevant follow-up questions the user might want to ask.  
          
        Always include the disclaimer: "This information is provided for general guidance only and does not constitute legal or financial advice. Consult with a qualified tax professional for advice specific to your situation."  
        """  
        
        return base\_prompt

#### **Database Models & Schema**

**Guest Session & User Management Schema:**

```python
# In app/db/models/session.py
class GuestSession(Base):
    __tablename__ = "guest_sessions"
    
    id = Column(String, primary_key=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    last_active = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    ip_address = Column(String, nullable=True)
    user_agent = Column(String, nullable=True)
    # Relationship with conversations
    conversations = relationship("Conversation", back_populates="guest_session")

# In app/db/models/conversation.py
class Conversation(Base):
    __tablename__ = "conversations"
    
    id = Column(UUID, primary_key=True, default=uuid.uuid4)
    # Can belong to authenticated user OR guest session
    user_id = Column(Integer, ForeignKey("users.id"), nullable=True)
    guest_session_id = Column(String, ForeignKey("guest_sessions.id"), nullable=True)
    # Ensure one or the other is set but not both
    __table_args__ = (
        CheckConstraint("(user_id IS NULL AND guest_session_id IS NOT NULL) OR (user_id IS NOT NULL AND guest_session_id IS NULL)"),
    )
    # Relationships
    user = relationship("User", back_populates="conversations")
    guest_session = relationship("GuestSession", back_populates="conversations")
    messages = relationship("Message", back_populates="conversation", cascade="all, delete-orphan")

# In app/db/models/message.py
class Message(Base):
    __tablename__ = "messages"
    
    id = Column(UUID, primary_key=True, default=uuid.uuid4)
    conversation_id = Column(UUID, ForeignKey("conversations.id"), nullable=False)
    role = Column(String, nullable=False)  # "user" or "assistant"
    content = Column(Text, nullable=False)
    created_at = Column(DateTime, default=datetime.utcnow)
    # LLM metadata
    llm_provider = Column(String, nullable=True)
    token_count = Column(Integer, nullable=True)
    # Relationships
    conversation = relationship("Conversation", back_populates="messages")

# In app/db/models/user.py
class User(Base):
    __tablename__ = "users"
    
    id = Column(Integer, primary_key=True)
    email = Column(String, unique=True, index=True)
    hashed_password = Column(String, nullable=False)
    created_at = Column(DateTime, default=datetime.utcnow)
    is_active = Column(Boolean, default=True)
    # Relationships
    conversations = relationship("Conversation", back_populates="user")
```

**Database Migration for Guest Sessions:**

The following Alembic migration will be generated to add the guest_sessions table and update the conversations table to support both user and guest associations:

```python
# In alembic/versions/xxxx_add_guest_sessions.py
def upgrade():
    # Create guest_sessions table
    op.create_table(
        "guest_sessions",
        sa.Column("id", sa.String(), primary_key=True),
        sa.Column("created_at", sa.DateTime(), nullable=False, default=sa.func.now()),
        sa.Column("last_active", sa.DateTime(), nullable=False, default=sa.func.now()),
        sa.Column("ip_address", sa.String(), nullable=True),
        sa.Column("user_agent", sa.String(), nullable=True),
    )
    
    # Add guest_session_id to conversations table
    op.add_column("conversations", sa.Column("guest_session_id", sa.String(), nullable=True))
    op.create_foreign_key(
        "fk_conversation_guest_session",
        "conversations", "guest_sessions",
        ["guest_session_id"], ["id"]
    )
    
    # Add check constraint to ensure either user_id or guest_session_id is set
    op.create_check_constraint(
        "ck_conversation_owner",
        "conversations",
        "(user_id IS NULL AND guest_session_id IS NOT NULL) OR (user_id IS NOT NULL AND guest_session_id IS NULL)"
    )

def downgrade():
    # Remove check constraint
    op.drop_constraint("ck_conversation_owner", "conversations")
    
    # Remove foreign key constraint and column
    op.drop_constraint("fk_conversation_guest_session", "conversations")
    op.drop_column("conversations", "guest_session_id")
    
    # Drop guest_sessions table
    op.drop_table("guest_sessions")
```

#### **Authentication & Session Management**

**Guest Session Management Utilities:**

```python
# In app/security/session.py
import secrets
import uuid
from datetime import datetime, timedelta
from fastapi import Request, Response
from app.db.models.session import GuestSession
from app.config import settings

GUEST_SESSION_COOKIE = "guest_session_id"
GUEST_SESSION_LENGTH = timedelta(days=30)  # Configurable session length

def generate_guest_session_id() -> str:
    """Generate a secure random session ID for guest users."""
    return secrets.token_urlsafe(32)

async def create_guest_session(db, request: Request) -> GuestSession:
    """Create a new guest session and store it in the database."""
    session_id = generate_guest_session_id()
    
    # Extract client information if available
    client_ip = request.client.host if request.client else None
    user_agent = request.headers.get("user-agent")
    
    # Create session record
    guest_session = GuestSession(
        id=session_id,
        ip_address=client_ip,
        user_agent=user_agent
    )
    
    db.add(guest_session)
    await db.commit()
    await db.refresh(guest_session)
    
    return guest_session

async def get_guest_session(db, request: Request) -> GuestSession:
    """Retrieve guest session from cookie or create a new one."""
    session_id = request.cookies.get(GUEST_SESSION_COOKIE)
    
    if session_id:
        # Try to fetch existing session
        guest_session = await db.query(GuestSession).filter(GuestSession.id == session_id).first()
        if guest_session:
            # Update last active timestamp
            guest_session.last_active = datetime.utcnow()
            await db.commit()
            return guest_session
    
    # Create new session if not found
    return await create_guest_session(db, request)

def set_guest_session_cookie(response: Response, session_id: str) -> None:
    """Set the guest session cookie on the response."""
    response.set_cookie(
        key=GUEST_SESSION_COOKIE,
        value=session_id,
        max_age=int(GUEST_SESSION_LENGTH.total_seconds()),
        httponly=True,
        secure=settings.COOKIE_SECURE,  # True in production
        samesite="lax"
    )
```

**Enhanced Authentication Dependencies:**

```python
# In app/dependencies/auth.py
from fastapi import Depends, HTTPException, status, Request, Response
from fastapi.security import OAuth2PasswordBearer
from sqlalchemy.ext.asyncio import AsyncSession
from app.db.session import get_db
from app.security.jwt import decode_access_token
from app.security.session import get_guest_session, set_guest_session_cookie
from app.db.models.user import User
from app.db.models.session import GuestSession

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token", auto_error=False)

async def get_current_user(
    token: str = Depends(oauth2_scheme),
    db: AsyncSession = Depends(get_db)
) -> User:
    """Get the current authenticated user or raise 401 error."""
    if not token:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Not authenticated",
            headers={"WWW-Authenticate": "Bearer"},
        )
    
    user_id = decode_access_token(token)
    if not user_id:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid authentication credentials",
            headers={"WWW-Authenticate": "Bearer"},
        )
    
    user = await db.query(User).filter(User.id == user_id).first()
    if not user:
        raise HTTPException(status_code=404, detail="User not found")
    
    return user

async def get_current_user_or_guest(
    request: Request,
    response: Response,
    token: str = Depends(oauth2_scheme),
    db: AsyncSession = Depends(get_db)
) -> tuple[User | None, GuestSession | None]:
    """
    Get either the current authenticated user or create/retrieve a guest session.
    Returns a tuple of (user, guest_session) where exactly one is None.
    """
    user = None
    guest_session = None
    
    # Try to get authenticated user first
    if token:
        user_id = decode_access_token(token)
        if user_id:
            user = await db.query(User).filter(User.id == user_id).first()
    
    # If no authenticated user, get or create guest session
    if not user:
        guest_session = await get_guest_session(db, request)
        set_guest_session_cookie(response, guest_session.id)
    
    return user, guest_session
```

#### **API Endpoints for Guest & User Sessions**

**Conversation API with Guest Support:**

```python
# In app/api/routes/conversations.py
from fastapi import APIRouter, Depends, HTTPException, Request, Response, status
from sqlalchemy.ext.asyncio import AsyncSession
from app.db.session import get_db
from app.dependencies.auth import get_current_user_or_guest
from app.services.conversation import ConversationService
from app.schemas.conversation import ConversationCreate, ConversationResponse, MessageCreate

router = APIRouter()

@router.post("/conversations/", response_model=ConversationResponse)
async def create_conversation(
    request: Request,
    response: Response,
    conversation_data: ConversationCreate,
    db: AsyncSession = Depends(get_db),
    auth: tuple = Depends(get_current_user_or_guest)
):
    """Create a new conversation for authenticated user or guest."""
    user, guest_session = auth
    
    conversation_service = ConversationService(db)
    
    if user:
        conversation = await conversation_service.create_conversation(
            title=conversation_data.title,
            user_id=user.id
        )
    else:
        conversation = await conversation_service.create_conversation(
            title=conversation_data.title,
            guest_session_id=guest_session.id
        )
    
    return conversation

@router.get("/conversations/", response_model=list[ConversationResponse])
async def get_conversations(
    request: Request,
    response: Response,
    db: AsyncSession = Depends(get_db),
    auth: tuple = Depends(get_current_user_or_guest)
):
    """Get all conversations for the current user or guest session."""
    user, guest_session = auth
    
    conversation_service = ConversationService(db)
    
    if user:
        conversations = await conversation_service.get_user_conversations(user.id)
    else:
        conversations = await conversation_service.get_guest_conversations(guest_session.id)
    
    return conversations
```

**Guest to User Conversion Endpoint:**

```python
# In app/api/routes/users.py
@router.post("/users/convert-guest/", response_model=UserResponse)
async def convert_guest_to_user(
    request: Request,
    response: Response,
    user_data: UserCreate,
    db: AsyncSession = Depends(get_db),
    auth: tuple = Depends(get_current_user_or_guest)
):
    """Convert a guest session to a registered user account."""
    user, guest_session = auth
    
    # If already authenticated, return error
    if user:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Already authenticated as a registered user"
        )
    
    if not guest_session:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="No guest session found"
        )
    
    # Create new user
    user_service = UserService(db)
    new_user = await user_service.create_user(user_data)
    
    # Transfer guest session conversations to new user
    conversation_service = ConversationService(db)
    await conversation_service.transfer_guest_conversations(
        guest_session_id=guest_session.id,
        user_id=new_user.id
    )
    
    # Clear guest session cookie
    response.delete_cookie(key=GUEST_SESSION_COOKIE)
    
    # Generate and return new access token
    token_data = {"sub": str(new_user.id)}
    access_token = create_access_token(data=token_data)
    
    return {"user": new_user, "access_token": access_token}
```

#### **Service Layer for Guest Users**

**Enhanced Conversation Service:**

```python
# In app/services/conversation.py
from sqlalchemy.ext.asyncio import AsyncSession
from app.db.models.conversation import Conversation
from app.db.models.message import Message

class ConversationService:
    def __init__(self, db: AsyncSession):
        self.db = db
    
    async def create_conversation(
        self, 
        title: str = "New Conversation", 
        user_id: int = None, 
        guest_session_id: str = None
    ) -> Conversation:
        """Create a conversation for either a user or a guest session."""
        if user_id is None and guest_session_id is None:
            raise ValueError("Either user_id or guest_session_id must be provided")
        
        if user_id is not None and guest_session_id is not None:
            raise ValueError("Only one of user_id or guest_session_id should be provided")
        
        conversation = Conversation(
            title=title,
            user_id=user_id,
            guest_session_id=guest_session_id
        )
        
        self.db.add(conversation)
        await self.db.commit()
        await self.db.refresh(conversation)
        
        return conversation
    
    async def get_user_conversations(self, user_id: int) -> list[Conversation]:
        """Get all conversations for a specific user."""
        conversations = await self.db.query(Conversation).filter(
            Conversation.user_id == user_id
        ).order_by(Conversation.created_at.desc()).all()
        
        return conversations
    
    async def get_guest_conversations(self, guest_session_id: str) -> list[Conversation]:
        """Get all conversations for a specific guest session."""
        conversations = await self.db.query(Conversation).filter(
            Conversation.guest_session_id == guest_session_id
        ).order_by(Conversation.created_at.desc()).all()
        
        return conversations
    
    async def transfer_guest_conversations(
        self, guest_session_id: str, user_id: int
    ) -> None:
        """Transfer all conversations from a guest session to a registered user."""
        conversations = await self.db.query(Conversation).filter(
            Conversation.guest_session_id == guest_session_id
        ).all()
        
        for conversation in conversations:
            conversation.user_id = user_id
            conversation.guest_session_id = None
        
        await self.db.commit()
```

### **Frontend Implementation Notes**

#### **Guest User Experience & Authentication Flow**

The frontend will provide a seamless experience for both guest and registered users, with an intuitive path to convert from guest to registered status.

**Authentication Context Provider:**

```typescript
// In src/contexts/AuthContext.tsx
import React, { createContext, useState, useEffect, useContext } from 'react';
import { User } from '../types/user';
import { api } from '../services/api';

interface AuthContextData {
  user: User | null;
  isGuest: boolean;
  isLoading: boolean;
  isAuthenticated: boolean;
  login: (email: string, password: string) => Promise<void>;
  logout: () => void;
  convertGuestToUser: (userData: UserCreateData) => Promise<void>;
}

const AuthContext = createContext<AuthContextData>({} as AuthContextData);

export const AuthProvider: React.FC = ({ children }) => {
  const [user, setUser] = useState<User | null>(null);
  const [isGuest, setIsGuest] = useState<boolean>(false);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    // Check for existing user session or guest cookie
    async function loadUserFromStorage() {
      setIsLoading(true);
      
      try {
        // Try to get user from token in localStorage
        const token = localStorage.getItem('@PawaIT:token');
        
        if (token) {
          api.defaults.headers.authorization = `Bearer ${token}`;
          const response = await api.get('/users/me');
          setUser(response.data);
          setIsGuest(false);
        } else {
          // No token, we're a guest - still need to fetch our guest ID from cookies
          // The cookie is httpOnly so we can't access it directly
          // Instead, we'll make a request that will use the cookie if present
          await api.get('/conversations'); // This will establish guest session if needed
          setIsGuest(true);
        }
      } catch (error) {
        // If token is invalid or expired, default to guest
        localStorage.removeItem('@PawaIT:token');
        setIsGuest(true);
      } finally {
        setIsLoading(false);
      }
    }
    
    loadUserFromStorage();
  }, []);

  const login = async (email: string, password: string) => {
    try {
      const response = await api.post('/token', { email, password });
      const { access_token, user } = response.data;
      
      localStorage.setItem('@PawaIT:token', access_token);
      api.defaults.headers.authorization = `Bearer ${access_token}`;
      
      setUser(user);
      setIsGuest(false);
    } catch (error) {
      throw error;
    }
  };
  
  const logout = () => {
    localStorage.removeItem('@PawaIT:token');
    delete api.defaults.headers.authorization;
    setUser(null);
    setIsGuest(true);
    // Note: guest session cookie persists so user can still access their guest data
  };
  
  const convertGuestToUser = async (userData: UserCreateData) => {
    try {
      const response = await api.post('/users/convert-guest', userData);
      const { access_token, user } = response.data;
      
      localStorage.setItem('@PawaIT:token', access_token);
      api.defaults.headers.authorization = `Bearer ${access_token}`;
      
      setUser(user);
      setIsGuest(false);
    } catch (error) {
      throw error;
    }
  };
  
  return (
    <AuthContext.Provider 
      value={{ 
        user, 
        isGuest, 
        isLoading, 
        isAuthenticated: !!user, 
        login, 
        logout,
        convertGuestToUser
      }}
    >
      {children}
    </AuthContext.Provider>
  );
};

export function useAuth(): AuthContextData {
  const context = useContext(AuthContext);
  return context;
}
```

**API Client Setup with Guest and User Support:**

```typescript
// In src/services/api.ts
import axios from 'axios';

const api = axios.create({
  baseURL: process.env.NEXT_PUBLIC_API_URL || 'http://localhost:8000',
  withCredentials: true, // Important for sending/receiving cookies
});

// Add interceptor to handle automatic session management
api.interceptors.response.use(
  response => response,
  error => {
    // Handle specific errors like 401 Unauthorized
    if (error.response && error.response.status === 401) {
      // If token is invalid but we have guest session cookie, still allow access
      const token = localStorage.getItem('@PawaIT:token');
      if (token) {
        // Clear token since it's invalid
        localStorage.removeItem('@PawaIT:token');
        delete api.defaults.headers.authorization;
        
        // Retry the request (without token, will use guest session)
        const originalRequest = error.config;
        delete originalRequest.headers.authorization;
        return axios(originalRequest);
      }
    }
    return Promise.reject(error);
  }
);

export { api };
```

**Guest to User Conversion UI Component:**

```typescript
// In src/components/GuestPrompt.tsx
import React, { useState } from 'react';
import { useAuth } from '../contexts/AuthContext';

export const GuestPrompt: React.FC = () => {
  const { isGuest, convertGuestToUser } = useAuth();
  const [isSignupModalOpen, setIsSignupModalOpen] = useState(false);
  const [formData, setFormData] = useState({
    name: '',
    email: '',
    password: '',
    confirmPassword: ''
  });
  const [errors, setErrors] = useState<Record<string, string>>({});
  const [isSubmitting, setIsSubmitting] = useState(false);
  
  if (!isGuest) return null; // Only show for guest users
  
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setIsSubmitting(true);
    
    // Basic validation
    const newErrors: Record<string, string> = {};
    if (!formData.name) newErrors.name = 'Name is required';
    if (!formData.email) newErrors.email = 'Email is required';
    if (!formData.password) newErrors.password = 'Password is required';
    if (formData.password !== formData.confirmPassword) {
      newErrors.confirmPassword = 'Passwords do not match';
    }
    
    if (Object.keys(newErrors).length > 0) {
      setErrors(newErrors);
      setIsSubmitting(false);
      return;
    }
    
    try {
      await convertGuestToUser({
        name: formData.name,
        email: formData.email,
        password: formData.password
      });
      setIsSignupModalOpen(false);
    } catch (error) {
      if (error.response?.data?.detail) {
        setErrors({ form: error.response.data.detail });
      } else {
        setErrors({ form: 'An error occurred. Please try again.' });
      }
    } finally {
      setIsSubmitting(false);
    }
  };
  
  return (
    <>
      <div className="guest-banner bg-yellow-100 p-2 text-center">
        <p className="text-sm">
          You're currently using PawaIT as a guest.{' '}
          <button 
            onClick={() => setIsSignupModalOpen(true)}
            className="text-blue-600 hover:underline"
          >
            Sign up
          </button>
          {' '}to save your chats and access more features!
        </p>
      </div>
      
      {/* Modal implementation for registration form */}
      {isSignupModalOpen && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
          <div className="bg-white p-6 rounded-lg w-full max-w-md">
            <h2 className="text-xl font-bold mb-4">Create Your Account</h2>
            <p className="mb-4 text-gray-600">
              Sign up to save your chat history and access premium features.
            </p>
            
            {errors.form && (
              <div className="bg-red-100 text-red-700 p-3 rounded mb-4">
                {errors.form}
              </div>
            )}
            
            <form onSubmit={handleSubmit}>
              {/* Form fields implementation */}
              <div className="mb-4">
                <label className="block text-gray-700 mb-1">Name</label>
                <input
                  type="text"
                  value={formData.name}
                  onChange={e => setFormData({...formData, name: e.target.value})}
                  className="w-full p-2 border rounded"
                />
                {errors.name && <p className="text-red-500 text-sm mt-1">{errors.name}</p>}
              </div>
              
              {/* Additional form fields... */}
              <div className="mb-4">
                <label className="block text-gray-700 mb-1">Email</label>
                <input
                  type="email"
                  value={formData.email}
                  onChange={e => setFormData({...formData, email: e.target.value})}
                  className="w-full p-2 border rounded"
                />
                {errors.email && <p className="text-red-500 text-sm mt-1">{errors.email}</p>}
              </div>
              
              <div className="mb-4">
                <label className="block text-gray-700 mb-1">Password</label>
                <input
                  type="password"
                  value={formData.password}
                  onChange={e => setFormData({...formData, password: e.target.value})}
                  className="w-full p-2 border rounded"
                />
                {errors.password && <p className="text-red-500 text-sm mt-1">{errors.password}</p>}
              </div>
              
              <div className="mb-6">
                <label className="block text-gray-700 mb-1">Confirm Password</label>
                <input
                  type="password"
                  value={formData.confirmPassword}
                  onChange={e => setFormData({...formData, confirmPassword: e.target.value})}
                  className="w-full p-2 border rounded"
                />
                {errors.confirmPassword && (
                  <p className="text-red-500 text-sm mt-1">{errors.confirmPassword}</p>
                )}
              </div>
              
              <div className="flex justify-end gap-2">
                <button
                  type="button"
                  onClick={() => setIsSignupModalOpen(false)}
                  className="px-4 py-2 text-gray-700 border rounded"
                >
                  Cancel
                </button>
                <button
                  type="submit"
                  disabled={isSubmitting}
                  className="px-4 py-2 bg-blue-600 text-white rounded disabled:bg-blue-400"
                >
                  {isSubmitting ? 'Creating Account...' : 'Create Account'}
                </button>
              </div>
            </form>
          </div>
        </div>
      )}
    </>
  );
};
```

#### **Data Models & Types for Guest Users**

```typescript
// In src/types/user.ts
export interface User {
  id: number;
  name: string;
  email: string;
  created_at: string;
}

export interface UserCreateData {
  name: string;
  email: string;
  password: string;
}

// In src/types/conversation.ts
export interface Conversation {
  id: number;
  title: string;
  created_at: string;
  updated_at: string;
  user_id: number | null;
  guest_session_id: string | null;
  messages: Message[];
}

export interface Message {
  id: number;
  content: string;
  is_from_user: boolean;
  created_at: string;
  conversation_id: number;
}

export interface ConversationCreateData {
  title: string;
}
```

### **Testing Requirements**

```pawait_prd.md
# **Product Requirements Document: Freelancer Tax Assistant (Production Spec)**

* **Version:** 2.1  
* **Date:** 2025-04-22  
* **Author:** Senior Software Engineer  
* **Status:** Draft

**Note:** This version incorporates requirements for production-grade features, significantly expanding the scope beyond the original assessment prototype. Development time and effort will be substantially higher.

## **1\. Introduction**

This document outlines the requirements for the "Freelancer Tax Assistant," a modern, conversational web application targeting freelancers. Users can engage in multi-turn conversations about tax-related questions, receiving informative, structured answers generated by selectable Large Language Models (LLMs). The application prioritizes security, reliability, and user experience, incorporating production-grade monitoring, logging, alerting, and persistent user history. The system supports both authenticated users with cross-device access and guest users with device-specific history, ensuring a seamless experience regardless of authentication status.

## **2\. Goals & Objectives**

* **Primary:** Deliver a secure, scalable, and reliable conversational AI application providing accurate tax information for freelancers.  
* **User Engagement:** Enable multi-turn conversations, allowing users to ask follow-up questions and refine their queries naturally.  
* **Accessibility:** Remove barriers to entry by allowing immediate use without registration while still providing persistent history.
* **Flexibility:** Support multiple underlying LLMs, allowing for potential selection based on user preference or performance characteristics.  
* **Reliability & Ops:** Implement comprehensive monitoring, logging, and alerting to ensure high availability and facilitate prompt issue resolution in a production environment.  
* **Security:** Integrate robust security measures to protect the application and its users from common threats.  
* **Persistence:** Provide users with persistent access to their query history across sessions.

## **3\. Functional Requirements (User Stories)**

### **Basic Interaction**

* **FR-01:** As a user, I want to access the web application via a standard web browser on both desktop and mobile devices.  
* **FR-02:** As a user, I want to see a clear text input area where I can type my tax-related question.  
* **FR-03:** As a user, I want to submit my message by clicking a button or pressing Enter.  
* **FR-04:** As a user, I want to see a visual indicator (e.g., loading spinner) while the application is processing my message.  
* **FR-05:** As a user, I want the AI-generated response to be displayed clearly in a conversational format with proper markdown formatting (bullets, sections, bold highlights).  
* **FR-06:** As a user, I want to see information about the LLM token usage for each turn of the conversation.  
* **FR-07:** As a user, I want to always see a disclaimer indicating that responses are not legal or financial advice.  
* **FR-08 (System):** The backend API must expose endpoints to manage conversational interactions.

### **Multi-Turn Conversation**

* **FR-11 (Multi-Turn):** As a user, I want the AI to remember the context of our current conversation, so I can ask follow-up questions without repeating previous information.  
* **FR-12 (System \- Multi-Turn):** The backend must manage conversation state (context) across multiple requests within a user session. This context must be passed to the LLM API on subsequent turns.

### **LLM Selection**

* **FR-13 (LLM Selection):** As a user, I want to optionally select which underlying LLM (e.g., Gemini, ChatGPT, Claude) powers the conversation, perhaps via a settings menu. (Default can be pre-set).  
* **FR-14 (System \- LLM Selection):** The backend must include an abstraction layer to interact with multiple different LLM APIs. API keys and configurations for all supported LLMs must be securely managed. The API must handle requests to use a specific LLM for a given conversation or user setting.

### **Persistent History**

* **FR-15 (Persistent History):** As a user (authenticated or guest), I want my conversation history to be saved automatically and persistently, so I can access it again from the same device or across devices (if authenticated).  
* **FR-16 (System \- Persistent History):** The backend must securely store user conversation history (queries, responses, context, timestamps) in a persistent database (e.g., PostgreSQL, MongoDB). For authenticated users, conversations are linked to user accounts. For guest users, conversations are linked to a secure device identifier. API endpoints for retrieving and potentially managing history are needed.

### **Guest User Features**

* **FR-42 (Guest Identity):** As a guest user, I want to use the tax assistant without signing up, while still maintaining persistent access to my conversation history on the same device.
* **FR-43 (System \- Guest Sessions):** The backend must generate and maintain secure guest session identifiers stored in browser storage (localStorage/cookies) to track unauthenticated users across visits.
* **FR-44 (Guest History):** As a guest user, I want the option to create an account and retain all my conversation history if I decide to register later.
* **FR-45 (System \- Identity Transition):** The backend must support migrating conversation history from a guest session to a registered user account when a user signs up.
* **FR-46 (Guest Limits):** As an operator, I want to set appropriate rate limits and feature restrictions for guest users to encourage registration while still providing value to casual users.
* **FR-47 (Device Syncing Notice):** As a guest user, I want to be informed that my conversation history is device-specific, with a suggestion to register for cross-device access.

### **Security Features**

* **FR-17 (Security \- Rate Limiting):** As an operator, I want API rate limiting implemented to prevent abuse and ensure fair usage.  
* **FR-18 (System \- Rate Limiting):** The backend must implement rate limiting (e.g., per user/IP) on API endpoints, particularly the LLM interaction endpoint. (e.g., using slowapi with Redis).  
* **FR-19 (Security \- WAF):** As an operator, I want the application protected by a Web Application Firewall (WAF) to block common web attacks (XSS, SQLi, etc.).  
* **FR-20 (System \- WAF):** The deployment architecture must include or integrate with a WAF service (e.g., Cloudflare, AWS WAF).  
* **FR-21 (Security \- Input Sanitization):** As an operator, I want robust input sanitization to prevent injection attacks targeting the application or the LLM.  
* **FR-22 (System \- Input Sanitization):** The backend must implement detailed input sanitization beyond basic validation, potentially using libraries like bleach or custom rules tailored to LLM interaction risks, before processing user input or sending it to an LLM.  
* **FR-23 (Security \- Captcha):** As an operator, I want Captcha protection on relevant forms (e.g., login, potentially query submission if unauthenticated) to prevent bot abuse.  
* **FR-24 (System \- Captcha):** The frontend must integrate a Captcha service (e.g., hCaptcha, Google reCAPTCHA). The backend must include verification logic for the Captcha response.

### **Operations & Monitoring**

* **FR-25 (Monitoring):** As an operator, I want real-time monitoring of application performance (request latency, error rates, resource utilization) and LLM API interactions (latency, error rates, token usage).  
* **FR-26 (System \- Monitoring):** The backend and potentially frontend must expose metrics in a format consumable by monitoring systems (e.g., Prometheus). Integrate with monitoring dashboards (e.g., Grafana, Datadog). Monitor LLM API performance and costs.  
* **FR-27 (Logging):** As an operator, I want detailed, structured logs for application events, errors, and key requests (including API calls, security events, user actions) aggregated in a central location.  
* **FR-28 (System \- Logging):** Implement structured logging (e.g., using structlog in Python) throughout the backend. Configure log shippers (e.g., Filebeat, Promtail) to send logs to an aggregation platform (e.g., ELK stack, Loki, Datadog Logs). Ensure appropriate log levels and information density.  
* **FR-29 (Alerting):** As an operator, I want to receive automated alerts for critical errors, performance degradation, security events, or anomalous LLM usage/costs.  
* **FR-30 (System \- Alerting):** Configure alerting rules based on metrics (e.g., via Prometheus Alertmanager) or logs. Integrate with notification channels (e.g., PagerDuty, Slack, Email).

### **User Experience Enhancements**

* **FR-31 (UI \- Suggested Questions):** As a user, I want to see a list of common tax-related questions I can click on to quickly get information.  
* **FR-32 (UI \- Follow-up Suggestions):** As a user, after receiving an answer, I want to see 3 relevant follow-up questions suggested by the AI to help guide the conversation or explore related topics.  
* **FR-33 (System \- Follow-up Suggestions):** The backend prompt engineering must instruct the LLM to generate relevant follow-up question suggestions based on the latest turn. The LLM response parsing must extract these suggestions. The API response model and frontend UI must accommodate displaying these suggestions.

### **System Requirements**

* **FR-34 (System):** The backend must perform enhanced input validation and sanitization on user messages.  
* **FR-35 (System):** The backend must securely load and manage API keys for multiple LLMs using environment variables or a secrets management system.  
* **FR-36 (System):** The backend must implement effective prompt engineering suitable for multi-turn conversations, including context management and instructions for generating follow-up questions.  
* **FR-37 (System):** The backend must handle communication with the selected LLM API, including request formatting and response parsing (including extracting follow-up suggestions).  
* **FR-38 (System):** The backend must gracefully handle errors from any supported LLM API and integrate error reporting with the logging/alerting systems.  
* **FR-39 (System):** The backend API response for a conversation turn must be structured (JSON) and include the answer text, token usage metadata, disclaimer information, and suggested follow-up questions.  
* **FR-40 (System):** The backend must configure CORS middleware.  
* **FR-41 (System):** The frontend must display user-friendly error messages, potentially with correlation IDs linking to backend logs for support.

## **4\. Non-Functional Requirements (NFRs)**

* **NFR-01: Performance**

  * Fast response times (\<1s UI response after submission)  
  * Efficient database queries for history retrieval  
  * Multiple LLM API latency considerations and potential fallbacks  
* **NFR-02: Security**

  * Authentication/authorization mechanisms  
  * Secure session management  
  * Database security  
  * Input validation and sanitization  
  * Protection against common web vulnerabilities  
* **NFR-03: Scalability**

  * Stateless backend design  
  * Database scaling strategies  
  * Redis scaling for rate limiting/caching  
  * Managing concurrent conversations  
* **NFR-04: Maintainability**

  * Modular code structure  
  * Comprehensive unit and integration testing  
  * Detailed code documentation  
  * Clear API documentation (e.g., Swagger)  
* **NFR-05: Design Patterns**

  * MVC-style organization for backend  
  * Atomic component structure for frontend  
  * State management patterns  
  * Multi-provider abstraction for LLMs  
  * Secure coding practices  
* **NFR-06: Cache Strategies**

  * Conversation state caching  
  * User session caching for both authenticated and guest users
  * Guest session identifier persistence in browser storage
  * Database query result caching  
  * Potential LLM response caching for common queries
* **NFR-07: Reliability**

  * High availability (\>99.9% uptime)  
  * Robust error handling  
  * Graceful degradation  
  * Failover mechanisms where appropriate  
* **NFR-08: Usability**

  * Intuitive conversational UI  
  * Clear tax information presentation  
  * Effective use of markdown formatting  
  * Mobile responsiveness  
  * Accessibility compliance  
* **NFR-09: Accessibility**

  * WCAG 2.1 AA compliance  
  * Screen reader compatibility  
  * Keyboard navigation  
  * Appropriate contrast ratios

## **5\. Design & UI/UX**

* **Layout:**

  * Conversational UI (chat interface)  
  * Clear distinction between user messages and AI responses  
  * Settings area for LLM selection  
  * Persistent disclaimer visibility  
* **Components:**

  * Input area (text area)  
  * Submit button  
  * Message bubbles with markdown rendering  
  * Conversation history panel  
  * Loading indicators  
  * Error messages  
  * Suggested questions list  
  * Follow-up question buttons/links  
  * LLM selection menu (optional)  
  * Guest user notification banner
  * Registration promotion for guest users
  * Device syncing limitations notice
* **Visual Design:**

  * Clean, professional aesthetic  
  * High readability for tax-related information  
  * Clear visual hierarchy for structured responses  
  * Consistent use of color and typography  
* **Frameworks:**

  * TailwindCSS  
  * Next.js/TypeScript (frontend)  
  * React component architecture  
* **Responsiveness & Accessibility:**

  * Mobile-first responsive design  
  * ARIA attributes for accessibility  
  * Keyboard navigation support  
  * Screen reader compatibility

## **6\. Prompt Engineering**

### **Base Template**

You are a helpful tax assistant for freelancers.  
The user will ask a tax-related question. Respond clearly and concisely.

Structure your response into:  
\- Applicable tax categories  
\- Deductible expenses (if relevant)  
\- Filing requirements and deadlines  
\- Exceptions or conditions

Use markdown formatting with bullet points, bold text for emphasis, and clear section headers.

After your answer, suggest 3 relevant follow-up questions the user might want to ask.

Always include the disclaimer: "This information is provided for general guidance only and does not constitute legal or financial advice. Consult with a qualified tax professional for advice specific to your situation."

## **7\. Technical Specifications Overview**

### **Backend Architecture**

#### **Framework & Core Technologies**

* **Python 3.11+** \- Selected for its rich ecosystem and strong ML/AI library support  
* **FastAPI** \- High-performance async framework with automatic OpenAPI documentation  
  * Dependency injection for service layers and configuration  
  * Pydantic for data validation and serialization  
  * Async request handling for optimal performance under load  
* **Uvicorn** \- ASGI server for production deployment  
* **Python Typing** \- Comprehensive type hints for improved code quality and IDE support

#### **Database Architecture**

* **Primary Storage: PostgreSQL 15+**

  * User profiles and authentication data  
  * Conversation history and metadata (both authenticated and guest)
  * Guest session management
  * SQLAlchemy 2.0 with async drivers for ORM  
  * Alembic for database migrations and versioning  
  * Database connection pooling for performance optimization
* **NoSQL: MongoDB**

  * Flexible storage for LLM conversation context  
  * Raw response data from LLMs  
  * Motor (async MongoDB driver) for non-blocking operations  
  * Document-based schema for flexible data storage

#### **Caching & Message Queuing**

* **Redis**

  * Rate limiting implementation  
  * Session state management  
  * Caching layer for frequently accessed data  
  * LLM response caching for common queries  
  * Pub/Sub for real-time notifications  
* **RabbitMQ**

  * Task queuing for asynchronous processing  
  * Background job handling for LLM interactions  
  * Retry mechanisms with dead letter exchanges  
  * Load leveling during traffic spikes

#### **LLM Integration**

* **Multi-Provider Abstraction Layer**

  * Factory pattern implementation for LLM service selection  
  * Unified interface for different LLM providers  
  * Fallback mechanisms when primary provider is unavailable  
  * Support for OpenAI, Anthropic, and Google models  
  * Custom prompt templates per provider optimization  
  * Token usage tracking and optimization  
* **Context Management**

  * Conversation state persistence  
  * Context windowing to maintain token limits  
  * Dynamic system prompts based on user settings

#### **Security Implementation**

* **Authentication**

  * JWT-based authentication flow  
  * OAuth 2.0 support for social login  
  * Token refresh mechanism  
  * Role-based access control
  * Guest session management with secure device identifiers
  * User conversion flow (guest to registered)
* **Input/Output Security**

  * Input validation with Pydantic models  
  * Input sanitization with bleach  
  * LLM prompt injection protection  
  * Custom security middlewares  
  * Content moderation for sensitive data  
* **API Security**

  * Rate limiting with sliding window algorithm  
  * Request throttling per user/IP  
  * CORS policy configuration  
  * API key management for third-party integrations  
  * Audit logging for security events

#### **Observability Stack**

* **Logging**

  * Structured logging with contextvars  
  * Log correlation with trace IDs  
  * Log levels configuration by environment  
  * Log rotation and retention policies  
* **Metrics**

  * Prometheus integration for metrics collection  
  * Custom metrics for LLM interactions  
  * Performance metrics for critical paths  
  * Business metrics for user engagement  
* **Monitoring**

  * Health check endpoints with detailed status  
  * Real-time dashboards with Grafana  
  * Latency histograms for performance tracking  
  * Custom alerting rules

### **Frontend Architecture**

#### **Framework & Core Technologies**

* **React 18+** \- For component-based UI with concurrent mode

  * Functional components with hooks architecture  
  * Custom hooks for reusable logic  
  * React Context for global state where appropriate  
  * Error boundaries for graceful failure handling  
* **Next.js 14+** \- For server-side rendering and API routes

  * App Router for improved routing  
  * Server components where appropriate  
  * API routes for backend proxy  
  * Image optimization  
* **TypeScript** \- For type safety and improved developer experience

  * Strict mode enabled  
  * Comprehensive type definitions  
  * Interface-based design  
  * Generic components for reusability

#### **State Management**

* **Application State**

  * Redux Toolkit for global state management  
  * RTK Query for data fetching and caching  
  * Immer for immutable state updates  
  * Redux persistence for offline capability
  * Guest session state management with localStorage/cookies  
* **Form Management**

  * React Hook Form for efficient form handling  
  * Zod for form validation schemas  
  * Controlled components for complex inputs

#### **UI Components & Styling**

* **Component Library**

  * Custom component library with atomic design principles  
  * Storybook documentation for component showcase  
  * Reusable layout components  
  * Accessibility-first component design  
* **Styling**

  * TailwindCSS for utility-first styling  
  * CSS variables for theming  
  * Responsive design breakpoints  
  * Dark/light mode support

#### **Client-Side Performance**

* **Optimization Techniques**

  * Code splitting by route  
  * Dynamic imports for heavy components  
  * Virtualized lists for long conversations  
  * Memoization of expensive components  
  * Web workers for heavy computations  
* **Caching Strategy**

  * SWR for data fetching with stale-while-revalidate  
  * Local storage for persistent user preferences  
  * Service worker for offline capabilities

#### **Testing Strategy**

* **Unit Testing**

  * React Testing Library for component testing  
  * Jest for utility functions  
  * Mock service worker for API mocking  
* **End-to-End Testing**

  * Cypress for critical user flows  
  * Playwright for cross-browser testing

### **DevOps & Deployment**

#### **Containerization**

* **Docker**  
  * Multi-stage builds for optimized images  
  * Separate development and production Dockerfiles  
  * Docker Compose for local development  
  * Container health checks  
  * Custom entrypoint scripts for initialization

#### **Orchestration**

* **Docker Swarm**  
  * Service definitions with scaling rules  
  * Rolling updates for zero-downtime deployment  
  * Secrets management for credentials  
  * Network isolation between services  
  * Volume management for persistent data

#### **CI/CD Pipeline**

* **GitHub Actions**  
  * Automated testing on pull requests  
  * Static code analysis with tools like mypy, eslint  
  * Security scanning with CodeQL  
  * Automated build and deployment process  
  * Environment-specific configuration

#### **Infrastructure**

* **Linux Server Configuration**

  * Hardened Ubuntu LTS base  
  * SSH key-only authentication  
  * UFW firewall configuration  
  * Fail2ban for SSH protection  
  * System resource monitoring  
* **Reverse Proxy & TLS**

  * Nginx reverse proxy configuration  
  * Let's Encrypt certificate automation  
  * HTTP/2 support  
  * Gzip compression  
  * Cache headers optimization

#### **Backup & Disaster Recovery**

* **Database Backups**

  * Automated daily backups  
  * Point-in-time recovery capability  
  * Cross-region backup storage  
  * Backup validation and testing  
* **Application Recovery**

  * Infrastructure as code with Terraform  
  * Documented restore procedures  
  * Regular recovery testing  
  * Backup environment for failover

## **8\. Implementation Details**

### **Backend Implementation Notes**

#### **FastAPI Application Structure**

backend/  
├── app/  
│   ├── api/  
│   │   ├── deps.py           \# Dependency injection  
│   │   ├── endpoints/  
│   │   │   ├── auth.py       \# Authentication endpoints  
│   │   │   ├── conversation.py  \# Conversation management  
│   │   │   ├── settings.py   \# User settings  
│   │   │   └── health.py     \# Health checks and metrics  
│   │   └── router.py         \# API router configuration  
│   ├── core/  
│   │   ├── config.py         \# Configuration management  
│   │   ├── security.py       \# Security utilities  
│   │   └── logging.py        \# Logging configuration  
│   ├── db/  
│   │   ├── session.py        \# Database session management  
│   │   └── models/           \# SQLAlchemy models  
│   ├── llm/  
│   │   ├── factory.py        \# LLM provider factory  
│   │   ├── base.py           \# Abstract base LLM class  
│   │   ├── openai.py         \# OpenAI implementation  
│   │   ├── claude.py         \# Anthropic implementation  
│   │   ├── gemini.py         \# Google implementation  
│   │   └── prompt\_templates/ \# Provider-specific templates  
│   ├── schemas/              \# Pydantic models  
│   ├── services/             \# Business logic  
│   │   ├── conversation.py   \# Conversation management  
│   │   ├── auth.py           \# Authentication service  
│   │   └── tax\_data.py       \# Tax information service  
│   └── utils/                \# Utility functions  
├── alembic/                  \# Database migrations  
├── tests/                    \# Test suite  
│   ├── conftest.py           \# Test fixtures  
│   ├── api/                  \# API tests  
│   ├── services/             \# Service tests  
│   └── llm/                  \# LLM integration tests  
├── Dockerfile                \# Production Docker image  
├── docker-compose.yml        \# Local development setup  
├── pyproject.toml            \# Dependencies and build config  
└── .env.example              \# Environment variables template

#### **Key Python Requirements**

\[tool.poetry.dependencies\]  
python \= "^3.11"  
fastapi \= "^0.110.0"  
uvicorn \= {extras \= \["standard"\], version \= "^0.27.0"}  
sqlalchemy \= "^2.0.27"  
asyncpg \= "^0.29.0"  
pydantic \= {extras \= \["email"\], version \= "^2.5.2"}  
alembic \= "^1.13.1"  
python-jose \= {extras \= \["cryptography"\], version \= "^3.3.0"}  
passlib \= {extras \= \["bcrypt"\], version \= "^1.7.4"}  
redis \= {extras \= \["hiredis"\], version \= "^5.0.1"}  
motor \= "^3.3.2"  
openai \= "^1.13.3"  
anthropic \= "^0.14.0"  
google-generativeai \= "^0.3.1"  
prometheus-fastapi-instrumentator \= "^6.1.0"  
structlog \= "^24.1.0"  
slowapi \= "^0.1.9"  
bleach \= "^6.1.0"  
aio-pika \= "^9.3.1"  \# RabbitMQ client

#### **FastAPI Route Implementation Example**

from fastapi import APIRouter, Depends, HTTPException, BackgroundTasks, Cookie, Request  
from sqlalchemy.ext.asyncio import AsyncSession  
from slowapi import Limiter  
from slowapi.util import get\_remote\_address
from typing import Optional
import uuid

from app.api.deps import get\_db, get\_current\_user_or_guest, get\_llm\_client  
from app.schemas.conversation import ConversationCreate, ConversationResponse  
from app.services.conversation import ConversationService  
from app.llm.base import BaseLLMClient  
from app.db.models.user import User
from app.core.security import create_guest_session

router \= APIRouter()  
limiter \= Limiter(key\_func=get\_remote\_address)

@router.post("/message", response\_model=ConversationResponse)  
@limiter.limit("10/minute")  
async def create\_message(  
    payload: ConversationCreate,  
    background\_tasks: BackgroundTasks,  
    request: Request,
    db: AsyncSession \= Depends(get\_db),  
    user_or_session: dict \= Depends(get\_current\_user_or_guest),  
    llm\_client: BaseLLMClient \= Depends(get\_llm\_client),
    guest_session_id: Optional[str] = Cookie(None)
):  
    """Process a new message in the conversation and get AI response"""  
    try:  
        service \= ConversationService(db, llm\_client)
        
        # Handle authenticated users vs guest sessions
        if user_or_session.get("type") == "authenticated":
            user_id = user_or_session["user"].id
            guest_id = None
            rate_limit = "20/minute"  # Higher limit for registered users
        else:
            user_id = None
            # Create a new guest session if needed
            if not guest_session_id:
                guest_session_id = create_guest_session(request)
            guest_id = guest_session_id
            rate_limit = "10/minute"  # Standard limit for guest users
        
        response \= await service.process\_message(  
            user\_id=user_id,  
            guest_id=guest_id,
            conversation\_id=payload.conversation\_id,  
            message=payload.message  
        )  
          
        # Track metrics and log interaction asynchronously  
        background\_tasks.add\_task(  
            service.track\_interaction,   
            user\_id=user_id,
            guest_id=guest_id,
            conversation\_id=response.conversation\_id,  
            tokens\_used=response.token\_usage  
        )  
          
        return response  
    except Exception as e:  
        # Log the exception with context  
        logger.exception(  
            "Error processing message",  
            user\_id=user_id if "user_id" in locals() else None,
            guest_id=guest_id if "guest_id" in locals() else None,
            conversation\_id=payload.conversation\_id,  
            error=str(e)  
        )  
        raise HTTPException(  
            status\_code=500,  
            detail="An error occurred while processing your message"  
        )

#### **LLM Service Implementation Example**

from abc import ABC, abstractmethod  
from typing import Dict, List, Optional, Union  
import structlog

logger \= structlog.get\_logger(\_\_name\_\_)

class BaseLLMClient(ABC):  
    """Abstract base class for LLM clients"""  
      
    @abstractmethod  
    async def generate\_response(  
        self,   
        message: str,   
        conversation\_history: List\[Dict\[str, str\]\],  
        \*\*kwargs  
    ) \-\> Dict\[str, Union\[str, int, List\[str\]\]\]:  
        """Generate a response from the LLM"""  
        pass

class OpenAIClient(BaseLLMClient):  
    """OpenAI implementation of LLM client"""  
      
    def \_\_init\_\_(self, api\_key: str, model: str \= "gpt-4o"):  
        from openai import AsyncOpenAI  
        self.client \= AsyncOpenAI(api\_key=api\_key)  
        self.model \= model  
          
    async def generate\_response(  
        self,   
        message: str,   
        conversation\_history: List\[Dict\[str, str\]\],  
        \*\*kwargs  
    ) \-\> Dict\[str, Union\[str, int, List\[str\]\]\]:  
        """Generate a response using OpenAI"""  
        try:  
            \# Format conversation history for OpenAI  
            messages \= self.\_format\_conversation\_history(conversation\_history)  
              
            \# Add system prompt  
            system\_prompt \= self.\_get\_system\_prompt()  
            messages.insert(0, {"role": "system", "content": system\_prompt})  
              
            \# Add user's message  
            messages.append({"role": "user", "content": message})  
              
            \# Call OpenAI API  
            response \= await self.client.chat.completions.create(  
                model=self.model,  
                messages=messages,  
                max\_tokens=1000,  
                temperature=0.7,  
                response\_format={"type": "json\_object"},  
                tools=\[  
                    {  
                        "type": "function",  
                        "function": {  
                            "name": "format\_tax\_response",  
                            "description": "Format a tax information response with follow-up questions",  
                            "parameters": {  
                                "type": "object",  
                                "properties": {  
                                    "answer": {  
                                        "type": "string",  
                                        "description": "The markdown-formatted tax advice"  
                                    },  
                                    "follow\_up\_questions": {  
                                        "type": "array",  
                                        "items": {"type": "string"},  
                                        "description": "3 suggested follow-up questions"  
                                    }  
                                },  
                                "required": \["answer", "follow\_up\_questions"\]  
                            }  
                        }  
                    }  
                \],  
                tool\_choice={"type": "function", "function": {"name": "format\_tax\_response"}}  
            )  
              
            \# Extract and format response  
            function\_call \= response.choices\[0\].message.tool\_calls\[0\].function  
            response\_data \= json.loads(function\_call.arguments)  
              
            return {  
                "answer": response\_data\["answer"\],  
                "follow\_up\_questions": response\_data\["follow\_up\_questions"\],  
                "token\_usage": {  
                    "prompt\_tokens": response.usage.prompt\_tokens,  
                    "completion\_tokens": response.usage.completion\_tokens,  
                    "total\_tokens": response.usage.total\_tokens  
                }  
            }  
        except Exception as e:  
            logger.exception("OpenAI API error", error=str(e))  
            raise  
      
    def \_format\_conversation\_history(self, history: List\[Dict\[str, str\]\]) \-\> List\[Dict\[str, str\]\]:  
        """Format conversation history for OpenAI API"""  
        formatted \= \[\]  
        for entry in history:  
            if entry\["role"\] \== "user":  
                formatted.append({"role": "user", "content": entry\["content"\]})  
            else:  
                formatted.append({"role": "assistant", "content": entry\["content"\]})  
        return formatted  
      
    def \_get\_system\_prompt(self) \-\> str:  
        """Get system prompt"""  
        base\_prompt \= """  
        You are a helpful tax assistant for freelancers.  
        The user will ask a tax-related question. Respond clearly and concisely.  
          
        Structure your response into:  
        \- Applicable tax categories  
        \- Deductible expenses (if relevant)  
        \- Filing requirements and deadlines  
        \- Exceptions or conditions  
          
        Use markdown formatting with bullet points, bold text for emphasis, and clear section headers.  
        After your answer, suggest 3 relevant follow-up questions the user might want to ask.  
          
        Always include the disclaimer: "This information is provided for general guidance only and does not constitute legal or financial advice. Consult with a qualified tax professional for advice specific to your situation."  
        """  
        
        return base\_prompt

#### **Database Models & Schema**

**Guest Session & User Management Schema:**

```python
# In app/db/models/session.py
class GuestSession(Base):
    __tablename__ = "guest_sessions"
    
    id = Column(String, primary_key=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    last_active = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    ip_address = Column(String, nullable=True)
    user_agent = Column(String, nullable=True)
    # Relationship with conversations
    conversations = relationship("Conversation", back_populates="guest_session")

# In app/db/models/conversation.py
class Conversation(Base):
    __tablename__ = "conversations"
    
    id = Column(UUID, primary_key=True, default=uuid.uuid4)
    # Can belong to authenticated user OR guest session
    user_id = Column(Integer, ForeignKey("users.id"), nullable=True)
    guest_session_id = Column(String, ForeignKey("guest_sessions.id"), nullable=True)
    # Ensure one or the other is set but not both
    __table_args__ = (
        CheckConstraint("(user_id IS NULL AND guest_session_id IS NOT NULL) OR (user_id IS NOT NULL AND guest_session_id IS NULL)"),
    )
    # Relationships
    user = relationship("User", back_populates="conversations")
    guest_session = relationship("GuestSession", back_populates="conversations")
    messages = relationship("Message", back_populates="conversation", cascade="all, delete-orphan")

# In app/db/models/message.py
class Message(Base):
    __tablename__ = "messages"
    
    id = Column(UUID, primary_key=True, default=uuid.uuid4)
    conversation_id = Column(UUID, ForeignKey("conversations.id"), nullable=False)
    role = Column(String, nullable=False)  # "user" or "assistant"
    content = Column(Text, nullable=False)
    created_at = Column(DateTime, default=datetime.utcnow)
    # LLM metadata
    llm_provider = Column(String, nullable=True)
    token_count = Column(Integer, nullable=True)
    # Relationships
    conversation = relationship("Conversation", back_populates="messages")

# In app/db/models/user.py
class User(Base):
    __tablename__ = "users"
    
    id = Column(Integer, primary_key=True)
    email = Column(String, unique=True, index=True)
    hashed_password = Column(String, nullable=False)
    created_at = Column(DateTime, default=datetime.utcnow)
    is_active = Column(Boolean, default=True)
    # Relationships
    conversations = relationship("Conversation", back_populates="user")
```

**Database Migration for Guest Sessions:**

The following Alembic migration will be generated to add the guest_sessions table and update the conversations table to support both user and guest associations:

```python
# In alembic/versions/xxxx_add_guest_sessions.py
def upgrade():
    # Create guest_sessions table
    op.create_table(
        "guest_sessions",
        sa.Column("id", sa.String(), primary_key=True),
        sa.Column("created_at", sa.DateTime(), nullable=False, default=sa.func.now()),
        sa.Column("last_active", sa.DateTime(), nullable=False, default=sa.func.now()),
        sa.Column("ip_address", sa.String(), nullable=True),
        sa.Column("user_agent", sa.String(), nullable=True),
    )
    
    # Add guest_session_id to conversations table
    op.add_column("conversations", sa.Column("guest_session_id", sa.String(), nullable=True))
    op.create_foreign_key(
        "fk_conversation_guest_session",
        "conversations", "guest_sessions",
        ["guest_session_id"], ["id"]
    )
    
    # Add check constraint to ensure either user_id or guest_session_id is set
    op.create_check_constraint(
        "ck_conversation_owner",
        "conversations",
        "(user_id IS NULL AND guest_session_id IS NOT NULL) OR (user_id IS NOT NULL AND guest_session_id IS NULL)"
    )

def downgrade():
    # Remove check constraint
    op.drop_constraint("ck_conversation_owner", "conversations")
    
    # Remove foreign key constraint and column
    op.drop_constraint("fk_conversation_guest_session", "conversations")
    op.drop_column("conversations", "guest_session_id")
    
    # Drop guest_sessions table
    op.drop_table("guest_sessions")
```

#### **Authentication & Session Management**

**Guest Session Management Utilities:**

```python
# In app/security/session.py
import secrets
import uuid
from datetime import datetime, timedelta
from fastapi import Request, Response
from app.db.models.session import GuestSession
from app.config import settings

GUEST_SESSION_COOKIE = "guest_session_id"
GUEST_SESSION_LENGTH = timedelta(days=30)  # Configurable session length

def generate_guest_session_id() -> str:
    """Generate a secure random session ID for guest users."""
    return secrets.token_urlsafe(32)

async def create_guest_session(db, request: Request) -> GuestSession:
    """Create a new guest session and store it in the database."""
    session_id = generate_guest_session_id()
    
    # Extract client information if available
    client_ip = request.client.host if request.client else None
    user_agent = request.headers.get("user-agent")
    
    # Create session record
    guest_session = GuestSession(
        id=session_id,
        ip_address=client_ip,
        user_agent=user_agent
    )
    
    db.add(guest_session)
    await db.commit()
    await db.refresh(guest_session)
    
    return guest_session

async def get_guest_session(db, request: Request) -> GuestSession:
    """Retrieve guest session from cookie or create a new one."""
    session_id = request.cookies.get(GUEST_SESSION_COOKIE)
    
    if session_id:
        # Try to fetch existing session
        guest_session = await db.query(GuestSession).filter(GuestSession.id == session_id).first()
        if guest_session:
            # Update last active timestamp
            guest_session.last_active = datetime.utcnow()
            await db.commit()
            return guest_session
    
    # Create new session if not found
    return await create_guest_session(db, request)

def set_guest_session_cookie(response: Response, session_id: str) -> None:
    """Set the guest session cookie on the response."""
    response.set_cookie(
        key=GUEST_SESSION_COOKIE,
        value=session_id,
        max_age=int(GUEST_SESSION_LENGTH.total_seconds()),
        httponly=True,
        secure=settings.COOKIE_SECURE,  # True in production
        samesite="lax"
    )
```

**Enhanced Authentication Dependencies:**

```python
# In app/dependencies/auth.py
from fastapi import Depends, HTTPException, status, Request, Response
from fastapi.security import OAuth2PasswordBearer
from sqlalchemy.ext.asyncio import AsyncSession
from app.db.session import get_db
from app.security.jwt import decode_access_token
from app.security.session import get_guest_session, set_guest_session_cookie
from app.db.models.user import User
from app.db.models.session import GuestSession

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token", auto_error=False)

async def get_current_user(
    token: str = Depends(oauth2_scheme),
    db: AsyncSession = Depends(get_db)
) -> User:
    """Get the current authenticated user or raise 401 error."""
    if not token:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Not authenticated",
            headers={"WWW-Authenticate": "Bearer"},
        )
    
    user_id = decode_access_token(token)
    if not user_id:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid authentication credentials",
            headers={"WWW-Authenticate": "Bearer"},
        )
    
    user = await db.query(User).filter(User.id == user_id).first()
    if not user:
        raise HTTPException(status_code=404, detail="User not found")
    
    return user

async def get_current_user_or_guest(
    request: Request,
    response: Response,
    token: str = Depends(oauth2_scheme),
    db: AsyncSession = Depends(get_db)
) -> tuple[User | None, GuestSession | None]:
    """
    Get either the current authenticated user or create/retrieve a guest session.
    Returns a tuple of (user, guest_session) where exactly one is None.
    """
    user = None
    guest_session = None
    
    # Try to get authenticated user first
    if token:
        user_id = decode_access_token(token)
        if user_id:
            user = await db.query(User).filter(User.id == user_id).first()
    
    # If no authenticated user, get or create guest session
    if not user:
        guest_session = await get_guest_session(db, request)
        set_guest_session_cookie(response, guest_session.id)
    
    return user, guest_session
```

#### **API Endpoints for Guest & User Sessions**

**Conversation API with Guest Support:**

```python
# In app/api/routes/conversations.py
from fastapi import APIRouter, Depends, HTTPException, Request, Response, status
from sqlalchemy.ext.asyncio import AsyncSession
from app.db.session import get_db
from app.dependencies.auth import get_current_user_or_guest
from app.services.conversation import ConversationService
from app.schemas.conversation import ConversationCreate, ConversationResponse, MessageCreate

router = APIRouter()

@router.post("/conversations/", response_model=ConversationResponse)
async def create_conversation(
    request: Request,
    response: Response,
    conversation_data: ConversationCreate,
    db: AsyncSession = Depends(get_db),
    auth: tuple = Depends(get_current_user_or_guest)
):
    """Create a new conversation for authenticated user or guest."""
    user, guest_session = auth
    
    conversation_service = ConversationService(db)
    
    if user:
        conversation = await conversation_service.create_conversation(
            title=conversation_data.title,
            user_id=user.id
        )
    else:
        conversation = await conversation_service.create_conversation(
            title=conversation_data.title,
            guest_session_id=guest_session.id
        )
    
    return conversation

@router.get("/conversations/", response_model=list[ConversationResponse])
async def get_conversations(
    request: Request,
    response: Response,
    db: AsyncSession = Depends(get_db),
    auth: tuple = Depends(get_current_user_or_guest)
):
    """Get all conversations for the current user or guest session."""
    user, guest_session = auth
    
    conversation_service = ConversationService(db)
    
    if user:
        conversations = await conversation_service.get_user_conversations(user.id)
    else:
        conversations = await conversation_service.get_guest_conversations(guest_session.id)
    
    return conversations
```

**Guest to User Conversion Endpoint:**

```python
# In app/api/routes/users.py
@router.post("/users/convert-guest/", response_model=UserResponse)
async def convert_guest_to_user(
    request: Request,
    response: Response,
    user_data: UserCreate,
    db: AsyncSession = Depends(get_db),
    auth: tuple = Depends(get_current_user_or_guest)
):
    """Convert a guest session to a registered user account."""
    user, guest_session = auth
    
    # If already authenticated, return error
    if user:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Already authenticated as a registered user"
        )
    
    if not guest_session:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="No guest session found"
        )
    
    # Create new user
    user_service = UserService(db)
    new_user = await user_service.create_user(user_data)
    
    # Transfer guest session conversations to new user
    conversation_service = ConversationService(db)
    await conversation_service.transfer_guest_conversations(
        guest_session_id=guest_session.id,
        user_id=new_user.id
    )
    
    # Clear guest session cookie
    response.delete_cookie(key=GUEST_SESSION_COOKIE)
    
    # Generate and return new access token
    token_data = {"sub": str(new_user.id)}
    access_token = create_access_token(data=token_data)
    
    return {"user": new_user, "access_token": access_token}
```

#### **Service Layer for Guest Users**

**Enhanced Conversation Service:**

```python
# In app/services/conversation.py
from sqlalchemy.ext.asyncio import AsyncSession
from app.db.models.conversation import Conversation
from app.db.models.message import Message

class ConversationService:
    def __init__(self, db: AsyncSession):
        self.db = db
    
    async def create_conversation(
        self, 
        title: str = "New Conversation", 
        user_id: int = None, 
        guest_session_id: str = None
    ) -> Conversation:
        """Create a conversation for either a user or a guest session."""
        if user_id is None and guest_session_id is None:
            raise ValueError("Either user_id or guest_session_id must be provided")
        
        if user_id is not None and guest_session_id is not None:
            raise ValueError("Only one of user_id or guest_session_id should be provided")
        
        conversation = Conversation(
            title=title,
            user_id=user_id,
            guest_session_id=guest_session_id
        )
        
        self.db.add(conversation)
        await self.db.commit()
        await self.db.refresh(conversation)
        
        return conversation
    
    async def get_user_conversations(self, user_id: int) -> list[Conversation]:
        """Get all conversations for a specific user."""
        conversations = await self.db.query(Conversation).filter(
            Conversation.user_id == user_id
        ).order_by(Conversation.created_at.desc()).all()
        
        return conversations
    
    async def get_guest_conversations(self, guest_session_id: str) -> list[Conversation]:
        """Get all conversations for a specific guest session."""
        conversations = await self.db.query(Conversation).filter(
            Conversation.guest_session_id == guest_session_id
        ).order_by(Conversation.created_at.desc()).all()
        
        return conversations
    
    async def transfer_guest_conversations(
        self, guest_session_id: str, user_id: int
    ) -> None:
        """Transfer all conversations from a guest session to a registered user."""
        conversations = await self.db.query(Conversation).filter(
            Conversation.guest_session_id == guest_session_id
        ).all()
        
        for conversation in conversations:
            conversation.user_id = user_id
            conversation.guest_session_id = None
        
        await self.db.commit()
```

### **Frontend Implementation Notes**

#### **Guest User Experience & Authentication Flow**

The frontend will provide a seamless experience for both guest and registered users, with an intuitive path to convert from guest to registered status.

**Authentication Context Provider:**

```typescript
// In src/contexts/AuthContext.tsx
import React, { createContext, useState, useEffect, useContext } from 'react';
import { User } from '../types/user';
import { api } from '../services/api';

interface AuthContextData {
  user: User | null;
  isGuest: boolean;
  isLoading: boolean;
  isAuthenticated: boolean;
  login: (email: string, password: string) => Promise<void>;
  logout: () => void;
  convertGuestToUser: (userData: UserCreateData) => Promise<void>;
}

const AuthContext = createContext<AuthContextData>({} as AuthContextData);

export const AuthProvider: React.FC = ({ children }) => {
  const [user, setUser] = useState<User | null>(null);
  const [isGuest, setIsGuest] = useState<boolean>(false);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    // Check for existing user session or guest cookie
    async function loadUserFromStorage() {
      setIsLoading(true);
      
      try {
        // Try to get user from token in localStorage
        const token = localStorage.getItem('@PawaIT:token');
        
        if (token) {
          api.defaults.headers.authorization = `Bearer ${token}`;
          const response = await api.get('/users/me');
          setUser(response.data);
          setIsGuest(false);
        } else {
          // No token, we're a guest - still need to fetch our guest ID from cookies
          // The cookie is httpOnly so we can't access it directly
          // Instead, we'll make a request that will use the cookie if present
          await api.get('/conversations'); // This will establish guest session if needed
          setIsGuest(true);
        }
      } catch (error) {
        // If token is invalid or expired, default to guest
        localStorage.removeItem('@PawaIT:token');
        setIsGuest(true);
      } finally {
        setIsLoading(false);
      }
    }
    
    loadUserFromStorage();
  }, []);

  const login = async (email: string, password: string) => {
    try {
      const response = await api.post('/token', { email, password });
      const { access_token, user } = response.data;
      
      localStorage.setItem('@PawaIT:token', access_token);
      api.defaults.headers.authorization = `Bearer ${access_token}`;
      
      setUser(user);
      setIsGuest(false);
    } catch (error) {
      throw error;
    }
  };
  
  const logout = () => {
    localStorage.removeItem('@PawaIT:token');
    delete api.defaults.headers.authorization;
    setUser(null);
    setIsGuest(true);
    // Note: guest session cookie persists so user can still access their guest data
  };
  
  const convertGuestToUser = async (userData: UserCreateData) => {
    try {
      const response = await api.post('/users/convert-guest', userData);
      const { access_token, user } = response.data;
      
      localStorage.setItem('@PawaIT:token', access_token);
      api.defaults.headers.authorization = `Bearer ${access_token}`;
      
      setUser(user);
      setIsGuest(false);
    } catch (error) {
      throw error;
    }
  };
  
  return (
    <AuthContext.Provider 
      value={{ 
        user, 
        isGuest, 
        isLoading, 
        isAuthenticated: !!user, 
        login, 
        logout,
        convertGuestToUser
      }}
    >
      {children}
    </AuthContext.Provider>
  );
};

export function useAuth(): AuthContextData {
  const context = useContext(AuthContext);
  return context;
}
```

**API Client Setup with Guest and User Support:**

```typescript
// In src/services/api.ts
import axios from 'axios';

const api = axios.create({
  baseURL: process.env.NEXT_PUBLIC_API_URL || 'http://localhost:8000',
  withCredentials: true, // Important for sending/receiving cookies
});

// Add interceptor to handle automatic session management
api.interceptors.response.use(
  response => response,
  error => {
    // Handle specific errors like 401 Unauthorized
    if (error.response && error.response.status === 401) {
      // If token is invalid but we have guest session cookie, still allow access
      const token = localStorage.getItem('@PawaIT:token');
      if (token) {
        // Clear token since it's invalid
        localStorage.removeItem('@PawaIT:token');
        delete api.defaults.headers.authorization;
        
        // Retry the request (without token, will use guest session)
        const originalRequest = error.config;
        delete originalRequest.headers.authorization;
        return axios(originalRequest);
      }
    }
    return Promise.reject(error);
  }
);

export { api };
```

**Guest to User Conversion UI Component:**

```typescript
// In src/components/GuestPrompt.tsx
import React, { useState } from 'react';
import { useAuth } from '../contexts/AuthContext';

export const GuestPrompt: React.FC = () => {
  const { isGuest, convertGuestToUser } = useAuth();
  const [isSignupModalOpen, setIsSignupModalOpen] = useState(false);
  const [formData, setFormData] = useState({
    name: '',
    email: '',
    password: '',
    confirmPassword: ''
  });
  const [errors, setErrors] = useState<Record<string, string>>({});
  const [isSubmitting, setIsSubmitting] = useState(false);
  
  if (!isGuest) return null; // Only show for guest users
  
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setIsSubmitting(true);
    
    // Basic validation
    const newErrors: Record<string, string> = {};
    if (!formData.name) newErrors.name = 'Name is required';
    if (!formData.email) newErrors.email = 'Email is required';
    if (!formData.password) newErrors.password = 'Password is required';
    if (formData.password !== formData.confirmPassword) {
      newErrors.confirmPassword = 'Passwords do not match';
    }
    
    if (Object.keys(newErrors).length > 0) {
      setErrors(newErrors);
      setIsSubmitting(false);
      return;
    }
    
    try {
      await convertGuestToUser({
        name: formData.name,
        email: formData.email,
        password: formData.password
      });
      setIsSignupModalOpen(false);
    } catch (error) {
      if (error.response?.data?.detail) {
        setErrors({ form: error.response.data.detail });
      } else {
        setErrors({ form: 'An error occurred. Please try again.' });
      }
    } finally {
      setIsSubmitting(false);
    }
  };
  
  return (
    <>
      <div className="guest-banner bg-yellow-100 p-2 text-center">
        <p className="text-sm">
          You're currently using PawaIT as a guest.{' '}
          <button 
            onClick={() => setIsSignupModalOpen(true)}
            className="text-blue-600 hover:underline"
          >
            Sign up
          </button>
          {' '}to save your chats and access more features!
        </p>
      </div>
      
      {/* Modal implementation for registration form */}
      {isSignupModalOpen && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
          <div className="bg-white p-6 rounded-lg w-full max-w-md">
            <h2 className="text-xl font-bold mb-4">Create Your Account</h2>
            <p className="mb-4 text-gray-600">
              Sign up to save your chat history and access premium features.
            </p>
            
            {errors.form && (
              <div className="bg-red-100 text-red-700 p-3 rounded mb-4">
                {errors.form}
              </div>
            )}
            
            <form onSubmit={handleSubmit}>
              {/* Form fields implementation */}
              <div className="mb-4">
                <label className="block text-gray-700 mb-1">Name</label>
                <input
                  type="text"
                  value={formData.name}
                  onChange={e => setFormData({...formData, name: e.target.value})}
                  className="w-full p-2 border rounded"
                />
                {errors.name && <p className="text-red-500 text-sm mt-1">{errors.name}</p>}
              </div>
              
              {/* Additional form fields... */}
              <div className="mb-4">
                <label className="block text-gray-700 mb-1">Email</label>
                <input
                  type="email"
                  value={formData.email}
                  onChange={e => setFormData({...formData, email: e.target.value})}
                  className="w-full p-2 border rounded"
                />
                {errors.email && <p className="text-red-500 text-sm mt-1">{errors.email}</p>}
              </div>
              
              <div className="mb-4">
                <label className="block text-gray-700 mb-1">Password</label>
                <input
                  type="password"
                  value={formData.password}
                  onChange={e => setFormData({...formData, password: e.target.value})}
                  className="w-full p-2 border rounded"
                />
                {errors.password && <p className="text-red-500 text-sm mt-1">{errors.password}</p>}
              </div>
              
              <div className="mb-6">
                <label className="block text-gray-700 mb-1">Confirm Password</label>
                <input
                  type="password"
                  value={formData.confirmPassword}
                  onChange={e => setFormData({...formData, confirmPassword: e.target.value})}
                  className="w-full p-2 border rounded"
                />
                {errors.confirmPassword && (
                  <p className="text-red-500 text-sm mt-1">{errors.confirmPassword}</p>
                )}
              </div>
              
              <div className="flex justify-end gap-2">
                <button
                  type="button"
                  onClick={() => setIsSignupModalOpen(false)}
                  className="px-4 py-2 text-gray-700 border rounded"
                >
                  Cancel
                </button>
                <button
                  type="submit"
                  disabled={isSubmitting}
                  className="px-4 py-2 bg-blue-600 text-white rounded disabled:bg-blue-400"
                >
                  {isSubmitting ? 'Creating Account...' : 'Create Account'}
                </button>
              </div>
            </form>
          </div>
        </div>
      )}
    </>
  );
};
```

#### **Data Models & Types for Guest Users**

```typescript
// In src/types/user.ts
export interface User {
  id: number;
  name: string;
  email: string;
  created_at: string;
}

export interface UserCreateData {
  name: string;
  email: string;
  password: string;
}

// In src/types/conversation.ts
export interface Conversation {
  id: number;
  title: string;
  created_at: string;
  updated_at: string;
  user_id: number | null;
  guest_session_id: string | null;
  messages: Message[];
}

export interface Message {
  id: number;
  content: string;
  is_from_user: boolean;
  created_at: string;
  conversation_id: number;
}

export interface ConversationCreateData {
  title: string;
}
```

### **Testing Requirements**

```pawait_prd.md
# **Product Requirements Document: Freelancer Tax Assistant (Production Spec)**

* **Version:** 2.1  
* **Date:** 2025-04-22  
* **Author:** Senior Software Engineer  
* **Status:** Draft

**Note:** This version incorporates requirements for production-grade features, significantly expanding the scope beyond the original assessment prototype. Development time and effort will be substantially higher.

## **1\. Introduction**

This document outlines the requirements for the "Freelancer Tax Assistant," a modern, conversational web application targeting freelancers. Users can engage in multi-turn conversations about tax-related questions, receiving informative, structured answers generated by selectable Large Language Models (LLMs). The application prioritizes security, reliability, and user experience, incorporating production-grade monitoring, logging, alerting, and persistent user history. The system supports both authenticated users with cross-device access and guest users with device-specific history, ensuring a seamless experience regardless of authentication status.

## **2\. Goals & Objectives**

* **Primary:** Deliver a secure, scalable, and reliable conversational AI application providing accurate tax information for freelancers.  
* **User Engagement:** Enable multi-turn conversations, allowing users to ask follow-up questions and refine their queries naturally.  
* **Accessibility:** Remove barriers to entry by allowing immediate use without registration while still providing persistent history.
* **Flexibility:** Support multiple underlying LLMs, allowing for potential selection based on user preference or performance characteristics.  
* **Reliability & Ops:** Implement comprehensive monitoring, logging, and alerting to ensure high availability and facilitate prompt issue resolution in a production environment.  
* **Security:** Integrate robust security measures to protect the application and its users from common threats.  
* **Persistence:** Provide users with persistent access to their query history across sessions.

## **3\. Functional Requirements (User Stories)**

### **Basic Interaction**

* **FR-01:** As a user, I want to access the web application via a standard web browser on both desktop and mobile devices.  
* **FR-02:** As a user, I want to see a clear text input area where I can type my tax-related question.  
* **FR-03:** As a user, I want to submit my message by clicking a button or pressing Enter.  
* **FR-04:** As a user, I want to see a visual indicator (e.g., loading spinner) while the application is processing my message.  
* **FR-05:** As a user, I want the AI-generated response to be displayed clearly in a conversational format with proper markdown formatting (bullets, sections, bold highlights).  
* **FR-06:** As a user, I want to see information about the LLM token usage for each turn of the conversation.  
* **FR-07:** As a user, I want to always see a disclaimer indicating that responses are not legal or financial advice.  
* **FR-08 (System):** The backend API must expose endpoints to manage conversational interactions.

### **Multi-Turn Conversation**

* **FR-11 (Multi-Turn):** As a user, I want the AI to remember the context of our current conversation, so I can ask follow-up questions without repeating previous information.  
* **FR-12 (System \- Multi-Turn):** The backend must manage conversation state (context) across multiple requests within a user session. This context must be passed to the LLM API on subsequent turns.

### **LLM Selection**

* **FR-13 (LLM Selection):** As a user, I want to optionally select which underlying LLM (e.g., Gemini, ChatGPT, Claude) powers the conversation, perhaps via a settings menu. (Default can be pre-set).  
* **FR-14 (System \- LLM Selection):** The backend must include an abstraction layer to interact with multiple different LLM APIs. API keys and configurations for all supported LLMs must be securely managed. The API must handle requests to use a specific LLM for a given conversation or user setting.

### **Persistent History**

* **FR-15 (Persistent History):** As a user (authenticated or guest), I want my conversation history to be saved automatically and persistently, so I can access it again from the same device or across devices (if authenticated).  
* **FR-16 (System \- Persistent History):** The backend must securely store user conversation history (queries, responses, context, timestamps) in a persistent database (e.g., PostgreSQL, MongoDB). For authenticated users, conversations are linked to user accounts. For guest users, conversations are linked to a secure device identifier. API endpoints for retrieving and potentially managing history are needed.

### **Guest User Features**

* **FR-42 (Guest Identity):** As a guest user, I want to use the tax assistant without signing up, while still maintaining persistent access to my conversation history on the same device.
* **FR-43 (System \- Guest Sessions):** The backend must generate and maintain secure guest session identifiers stored in browser storage (localStorage/cookies) to track unauthenticated users across visits.
* **FR-44 (Guest History):** As a guest user, I want the option to create an account and retain all my conversation history if I decide to register later.
* **FR-45 (System \- Identity Transition):** The backend must support migrating conversation history from a guest session to a registered user account when a user signs up.
* **FR-46 (Guest Limits):** As an operator, I want to set appropriate rate limits and feature restrictions for guest users to encourage registration while still providing value to casual users.
* **FR-47 (Device Syncing Notice):** As a guest user, I want to be informed that my conversation history is device-specific, with a suggestion to register for cross-device access.

### **Security Features**

* **FR-17 (Security \- Rate Limiting):** As an operator, I want API rate limiting implemented to prevent abuse and ensure fair usage.  
* **FR-18 (System \- Rate Limiting):** The backend must implement rate limiting (e.g., per user/IP) on API endpoints, particularly the LLM interaction endpoint. (e.g., using slowapi with Redis).  
* **FR-19 (Security \- WAF):** As an operator, I want the application protected by a Web Application Firewall (WAF) to block common web attacks (XSS, SQLi, etc.).  
* **FR-20 (System \- WAF):** The deployment architecture must include or integrate with a WAF service (e.g., Cloudflare, AWS WAF).  
* **FR-21 (Security \- Input Sanitization):** As an operator, I want robust input sanitization to prevent injection attacks targeting the application or the LLM.  
* **FR-22 (System \- Input Sanitization):** The backend must implement detailed input sanitization beyond basic validation, potentially using libraries like bleach or custom rules tailored to LLM interaction risks, before processing user input or sending it to an LLM.  
* **FR-23 (Security \- Captcha):** As an operator, I want Captcha protection on relevant forms (e.g., login, potentially query submission if unauthenticated) to prevent bot abuse.  
* **FR-24 (System \- Captcha):** The frontend must integrate a Captcha service (e.g., hCaptcha, Google reCAPTCHA). The backend must include verification logic for the Captcha response.

### **Operations & Monitoring**

* **FR-25 (Monitoring):** As an operator, I want real-time monitoring of application performance (request latency, error rates, resource utilization) and LLM API interactions (latency, error rates, token usage).  
* **FR-26 (System \- Monitoring):** The backend and potentially frontend must expose metrics in a format consumable by monitoring systems (e.g., Prometheus). Integrate with monitoring dashboards (e.g., Grafana, Datadog). Monitor LLM API performance and costs.  
* **FR-27 (Logging):** As an operator, I want detailed, structured logs for application events, errors, and key requests (including API calls, security events, user actions) aggregated in a central location.  
* **FR-28 (System \- Logging):** Implement structured logging (e.g., using structlog in Python) throughout the backend. Configure log shippers (e.g., Filebeat, Promtail) to send logs to an aggregation platform (e.g., ELK stack, Loki, Datadog Logs). Ensure appropriate log levels and information density.  
* **FR-29 (Alerting):** As an operator, I want to receive automated alerts for critical errors, performance degradation, security events, or anomalous LLM usage/costs.  
* **FR-30 (System \- Alerting):** Configure alerting rules based on metrics (e.g., via Prometheus Alertmanager) or logs. Integrate with notification channels (e.g., PagerDuty, Slack, Email).

### **User Experience Enhancements**

* **FR-31 (UI \- Suggested Questions):** As a user, I want to see a list of common tax-related questions I can click on to quickly get information.  
* **FR-32 (UI \- Follow-up Suggestions):** As a user, after receiving an answer, I want to see 3 relevant follow-up questions suggested by the AI to help guide the conversation or explore related topics.  
* **FR-33 (System \- Follow-up Suggestions):** The backend prompt engineering must instruct the LLM to generate relevant follow-up question suggestions based on the latest turn. The LLM response parsing must extract these suggestions. The API response model and frontend UI must accommodate displaying these suggestions.

### **System Requirements**

* **FR-34 (System):** The backend must perform enhanced input validation and sanitization on user messages.  
* **FR-35 (System):** The backend must securely load and manage API keys for multiple LLMs using environment variables or a secrets management system.  
* **FR-36 (System):** The backend must implement effective prompt engineering suitable for multi-turn conversations, including context management and instructions for generating follow-up questions.  
* **FR-37 (System):** The backend must handle communication with the selected LLM API, including request formatting and response parsing (including extracting follow-up suggestions).  
* **FR-38 (System):** The backend must gracefully handle errors from any supported LLM API and integrate error reporting with the logging/alerting systems.  
                <label className="block text-gray-