# **Product Requirements Document: Freelancer Tax Assistant (Supabase Spec)**

* **Version:** 1.0  
* **Date:** 2025-04-22  
* **Author:** Senior Software Engineer  
* **Status:** Draft

**Note:** This version adapts the original production spec to utilize Supabase for Authentication (via Edge Functions implicitly) and Database hosting. Core application features remain, but the backend infrastructure and implementation details are adjusted accordingly.

## **1\. Introduction**

This document outlines the requirements for the "Freelancer Tax Assistant," a modern, conversational web application targeting freelancers. Users can engage in multi-turn conversations about tax-related questions, receiving informative, structured answers generated by selectable Large Language Models (LLMs). The application leverages **Supabase for its managed PostgreSQL database and authentication services**, prioritizing security, reliability, and user experience. It incorporates production-grade monitoring, logging, alerting, and persistent user history. The system supports both authenticated users (via Supabase Auth) with cross-device access and guest (anonymous) users with device-specific history managed by Supabase, ensuring a seamless experience.

## **2\. Goals & Objectives**

* **Primary:** Deliver a secure, scalable, and reliable conversational AI application providing accurate tax information for freelancers, built upon the Supabase platform.
* **User Engagement:** Enable multi-turn conversations, allowing users to ask follow-up questions and refine their queries naturally.  
* **Accessibility:** Remove barriers to entry by allowing immediate use without registration (leveraging Supabase anonymous users) while still providing persistent history.
* **Flexibility:** Support multiple underlying LLMs, allowing for potential selection based on user preference or performance characteristics.  
* **Reliability & Ops:** Implement comprehensive monitoring, logging, and alerting, integrating Supabase's observability features where applicable, to ensure high availability and facilitate prompt issue resolution.
* **Security:** Integrate robust security measures, utilizing Supabase Auth features (including Row Level Security - RLS) and standard web security practices.
* **Persistence:** Provide users with persistent access to their query history across sessions, stored securely in the Supabase database.

## **3\. Functional Requirements (User Stories)**

### **Basic Interaction**

* **FR-01:** As a user, I want to access the web application via a standard web browser on both desktop and mobile devices.  
* **FR-02:** As a user, I want to see a clear text input area where I can type my tax-related question.  
* **FR-03:** As a user, I want to submit my message by clicking a button or pressing Enter.  
* **FR-04:** As a user, I want to see a visual indicator (e.g., loading spinner) while the application is processing my message.  
* **FR-05:** As a user, I want the AI-generated response to be displayed clearly in a conversational format with proper markdown formatting (bullets, sections, bold highlights).  
* **FR-06:** As a user, I want to see information about the LLM token usage for each turn of the conversation.  
* **FR-07:** As a user, I want to always see a disclaimer indicating that responses are not legal or financial advice.  
* **FR-08 (System):** The backend API (FastAPI) must expose endpoints to manage conversational interactions, secured appropriately.

### **Multi-Turn Conversation**

* **FR-11 (Multi-Turn):** As a user, I want the AI to remember the context of our current conversation, so I can ask follow-up questions without repeating previous information.  
* **FR-12 (System \- Multi-Turn):** The backend must manage conversation state (context) across multiple requests within a user session (identified via Supabase Auth). This context must be passed to the LLM API on subsequent turns.

### **LLM Selection**

* **FR-13 (LLM Selection):** As a user, I want to optionally select which underlying LLM (e.g., Gemini, ChatGPT, Claude) powers the conversation, perhaps via a settings menu. (Default can be pre-set).  
* **FR-14 (System \- LLM Selection):** The backend must include an abstraction layer to interact with multiple different LLM APIs. API keys and configurations for all supported LLMs must be securely managed (e.g., using environment variables or a secrets manager). The API must handle requests to use a specific LLM for a given conversation or user setting.

### **Persistent History**

* **FR-15 (Persistent History):** As a user (authenticated or anonymous), I want my conversation history to be saved automatically and persistently in my Supabase user account, so I can access it again from the same device (if anonymous) or across devices (if authenticated).
* **FR-16 (System \- Persistent History):** The backend must securely store user conversation history (queries, responses, context, timestamps) in the Supabase PostgreSQL database. Conversations must be linked to Supabase user IDs (including anonymous user IDs). Row Level Security (RLS) policies must ensure users can only access their own conversations. API endpoints for retrieving and potentially managing history are needed.

### **Guest (Anonymous) User Features**

* **FR-42 (Guest Identity):** As a guest user, I want to use the tax assistant without signing up (using Supabase anonymous authentication), while still maintaining persistent access to my conversation history on the same device.
* **FR-43 (System \- Guest Sessions):** Supabase Auth will handle the generation and management of anonymous user sessions. The frontend Supabase client library will manage session persistence.
* **FR-44 (Guest History):** As an anonymous user, I want the option to create a permanent account (sign up) and link my existing conversation history to my new registered account.
* **FR-45 (System \- Identity Transition):** The backend/frontend must leverage Supabase Auth's features to link an anonymous user's session and data (via their anonymous user ID) to a newly created registered user account upon sign-up. RLS policies must correctly handle ownership transfer.
* **FR-46 (Guest Limits):** As an operator, I want to set appropriate rate limits (potentially via API gateway or backend logic) and feature restrictions for anonymous users to encourage registration while still providing value. Supabase Auth roles could potentially be used.
* **FR-47 (Device Syncing Notice):** As an anonymous user, I want to be informed that my conversation history is device-specific, with a suggestion to register for cross-device access.

### **Security Features**

* **FR-17 (Security \- Rate Limiting):** As an operator, I want API rate limiting implemented (e.g., via API Gateway, backend middleware like `slowapi`, or potentially Supabase Function hooks if applicable) to prevent abuse and ensure fair usage, possibly differentiating between anonymous and registered users.
* **FR-18 (System \- Rate Limiting):** The backend/infra must implement rate limiting on API endpoints, particularly the LLM interaction endpoint.
* **FR-19 (Security \- WAF):** As an operator, I want the application protected by a Web Application Firewall (WAF) (e.g., Cloudflare in front of the FastAPI backend) to block common web attacks.
* **FR-20 (System \- WAF):** The deployment architecture must include or integrate with a WAF service.
* **FR-21 (Security \- Input Sanitization):** As an operator, I want robust input sanitization to prevent injection attacks targeting the application or the LLM.
* **FR-22 (System \- Input Sanitization):** The backend must implement detailed input sanitization (e.g., using `bleach`) before processing user input or sending it to an LLM.
* **FR-23 (Security \- Captcha):** As an operator, I want Captcha protection on relevant forms (e.g., login/signup via Supabase) to prevent bot abuse.
* **FR-24 (System \- Captcha):** Integrate Captcha services (e.g., hCaptcha, Turnstile) with Supabase Auth flows where possible, or implement verification in the frontend/backend for custom flows.
* **FR-48 (Security - RLS):** As an operator, I want Supabase Row Level Security (RLS) policies configured on all relevant tables (e.g., `conversations`, `messages`) to ensure users can only access their own data.

### **Operations & Monitoring**

* **FR-25 (Monitoring):** As an operator, I want real-time monitoring of application performance (request latency, error rates, resource utilization via FastAPI instrumentation) and LLM API interactions (latency, error rates, token usage). Integrate Supabase built-in monitoring for database and auth performance.
* **FR-26 (System \- Monitoring):** The backend must expose metrics (e.g., Prometheus). Utilize Supabase dashboards and logs. Integrate with external monitoring dashboards (e.g., Grafana, Datadog). Monitor LLM API performance and costs.
* **FR-27 (Logging):** As an operator, I want detailed, structured logs for application events, errors, and key requests (including API calls, security events, user actions) aggregated in a central location. Utilize Supabase logs for DB/Auth events.
* **FR-28 (System \- Logging):** Implement structured logging (e.g., `structlog`) in the FastAPI backend. Configure log shippers for backend logs if needed, or use a managed logging service. Access Supabase logs via its platform.
* **FR-29 (Alerting):** As an operator, I want to receive automated alerts for critical errors (backend, LLM), performance degradation (backend, Supabase), security events (Supabase Auth logs, WAF), or anomalous LLM usage/costs.
* **FR-30 (System \- Alerting):** Configure alerting rules based on metrics (e.g., Prometheus Alertmanager) or logs (from backend and Supabase). Integrate with notification channels (e.g., PagerDuty, Slack, Email).

### **User Experience Enhancements**

* **FR-31 (UI \- Suggested Questions):** As a user, I want to see a list of common tax-related questions I can click on to quickly get information.  
* **FR-32 (UI \- Follow-up Suggestions):** As a user, after receiving an answer, I want to see 3 relevant follow-up questions suggested by the AI to help guide the conversation or explore related topics.  
* **FR-33 (System \- Follow-up Suggestions):** The backend prompt engineering must instruct the LLM to generate relevant follow-up question suggestions based on the latest turn. The LLM response parsing must extract these suggestions. The API response model and frontend UI must accommodate displaying these suggestions.

### **System Requirements**

* **FR-34 (System):** The backend must perform enhanced input validation and sanitization on user messages.  
* **FR-35 (System):** The backend must securely load and manage API keys for multiple LLMs using environment variables or a secrets management system (like Supabase secrets if running functions, or external managers).
* **FR-36 (System):** The backend must implement effective prompt engineering suitable for multi-turn conversations, including context management and instructions for generating follow-up questions.  
* **FR-37 (System):** The backend must handle communication with the selected LLM API, including request formatting and response parsing.
* **FR-38 (System):** The backend must gracefully handle errors from any supported LLM API and integrate error reporting with the logging/alerting systems.  
* **FR-39 (System):** The backend API response for a conversation turn must be structured (JSON) and include the answer text, token usage metadata, disclaimer information, and suggested follow-up questions.  
* **FR-40 (System):** The backend (FastAPI) must configure CORS middleware appropriately to allow requests from the frontend domain.
* **FR-41 (System):** The frontend must display user-friendly error messages, potentially with correlation IDs linking to backend logs for support.
* **FR-49 (System - DB Schema):** The Supabase database schema must be managed via Supabase migrations.
* **FR-50 (System - Auth Integration):** The FastAPI backend must integrate with Supabase Auth to verify user identity from tokens passed by the frontend.

## **4\. Non-Functional Requirements (NFRs)**

* **NFR-01: Performance**

  * Fast response times (\<1s UI response after submission for non-LLM actions).
  * Efficient database queries leveraging Supabase PostgreSQL indexing.
  * Monitor Supabase DB performance metrics.
  * Multiple LLM API latency considerations.
* **NFR-02: Security**

  * Rely on Supabase Auth for secure authentication (including anonymous), JWT handling, and potentially password policies, MFA etc.
  * Implement strict Supabase Row Level Security (RLS) policies.
  * Secure Supabase API keys and service roles.
  * Input validation and sanitization in the backend.
  * Protection against common web vulnerabilities (via WAF, best practices).
* **NFR-03: Scalability**

  * Stateless backend (FastAPI) design.
  * Leverage Supabase's managed scaling for Database and Auth services.
  * Consider scaling strategies for the FastAPI service layer (e.g., container orchestration).
  * Redis scaling for rate limiting/caching if used.
* **NFR-04: Maintainability**

  * Modular code structure in FastAPI backend and React frontend.
  * Comprehensive unit and integration testing (mocking Supabase interactions).
  * Detailed code documentation.
  * Clear API documentation (FastAPI auto-docs).
  * Use Supabase CLI for managing migrations and local development environment.
* **NFR-05: Design Patterns**

  * MVC-style organization for backend.
  * Atomic component structure for frontend.
  * State management patterns (React Context, Redux Toolkit, Zustand) potentially integrating Supabase real-time subscriptions.
  * Multi-provider abstraction for LLMs.
  * Secure coding practices.
* **NFR-06: Cache Strategies**

  * Conversation context caching (e.g., Redis or alternative).
  * User session managed by Supabase client library.
  * Database query result caching (application-level if needed, e.g., Redis).
  * Potential LLM response caching for common queries.
* **NFR-07: Reliability**

  * High availability leveraging Supabase platform uptime (\>99.9% target).
  * Robust error handling in backend and frontend.
  * Graceful degradation.
  * Utilize Supabase's Point-in-Time Recovery (PITR) for database reliability.
* **NFR-08: Usability**

  * Intuitive conversational UI.
  * Clear tax information presentation.
  * Effective use of markdown formatting.
  * Mobile responsiveness.
  * Accessibility compliance.
* **NFR-09: Accessibility**

  * WCAG 2.1 AA compliance.
  * Screen reader compatibility.
  * Keyboard navigation.
  * Appropriate contrast ratios.

## **5\. Design & UI/UX**

* **Layout:**

  * Conversational UI (chat interface).
  * Clear distinction between user messages and AI responses.
  * Settings area for LLM selection.
  * Persistent disclaimer visibility.
* **Components:**

  * Input area (text area).
  * Submit button.
  * Message bubbles with markdown rendering.
  * Conversation history panel.
  * Loading indicators.
  * Error messages.
  * Suggested questions list.
  * Follow-up question buttons/links.
  * LLM selection menu (optional).
  * Anonymous user notification banner (prompting sign-up).
  * Sign-up/Login forms (potentially using Supabase UI components or custom forms interacting with Supabase Auth).
  * Device syncing limitations notice for anonymous users.
* **Visual Design:**

  * Clean, professional aesthetic.
  * High readability for tax-related information.
  * Clear visual hierarchy for structured responses.
  * Consistent use of color and typography.
* **Frameworks:**

  * TailwindCSS.
  * Next.js/TypeScript (frontend).
  * React component architecture.
* **Responsiveness & Accessibility:**

  * Mobile-first responsive design.
  * ARIA attributes for accessibility.
  * Keyboard navigation support.
  * Screen reader compatibility.

## **6\. Prompt Engineering**

### **Base Template**

(Unchanged from original PRD)

You are a helpful tax assistant for freelancers.  
The user will ask a tax-related question. Respond clearly and concisely.

Structure your response into:  
\- Applicable tax categories  
\- Deductible expenses (if relevant)  
\- Filing requirements and deadlines  
\- Exceptions or conditions

Use markdown formatting with bullet points, bold text for emphasis, and clear section headers.

After your answer, suggest 3 relevant follow-up questions the user might want to ask.

Always include the disclaimer: "This information is provided for general guidance only and does not constitute legal or financial advice. Consult with a qualified tax professional for advice specific to your situation."

## **7\. Technical Specifications Overview**

### **Backend Architecture (FastAPI + Supabase)**

#### **Framework & Core Technologies**

* **Python 3.11+** \- For the primary backend service.
* **FastAPI** \- High-performance async framework for the core API logic.
  * Dependency injection for service layers and configuration.
  * Pydantic for data validation and serialization.
  * Async request handling.
* **Uvicorn** \- ASGI server for production deployment of FastAPI.
* **Python Typing** \- Comprehensive type hints.
* **Supabase Python Library (`supabase-py`)** - For interacting with Supabase Database and potentially Admin functions from the backend.

#### **Database Architecture**

* **Primary Storage: Supabase Managed PostgreSQL 15+**

  * User profiles managed by Supabase Auth (accessible via `auth.users` table).
  * Conversation history and messages stored in custom tables within the Supabase DB.
  * **Row Level Security (RLS)** enforced on all user-data tables.
  * Database interactions via `supabase-py` or direct SQL if necessary.
  * Supabase Migrations for schema management.
* **NoSQL: MongoDB (Optional)**

  * Consider if still needed for flexible LLM context storage or if Supabase JSONB type is sufficient. *Decision: Assume JSONB is sufficient unless proven otherwise.*

#### **Caching & Message Queuing**

* **Redis (Optional / Recommended)**

  * Rate limiting implementation (if not handled by API gateway/Supabase limits).
  * Application-level caching (e.g., frequent DB queries, LLM responses).
  * Pub/Sub for real-time features (though Supabase Realtime could be an alternative).
* **RabbitMQ (Optional / Recommended)**

  * Task queuing for long-running background jobs (e.g., complex LLM processing, analytics).
  * Retry mechanisms.

#### **LLM Integration**

* **Multi-Provider Abstraction Layer (within FastAPI)**

  * Factory pattern implementation for LLM service selection.
  * Unified interface for different LLM providers (OpenAI, Anthropic, Google).
  * Secure management of LLM API keys.
  * Token usage tracking.
* **Context Management**

  * Conversation state persistence (potentially in Supabase DB or Redis/MongoDB if kept).
  * Context windowing.

#### **Security Implementation**

* **Authentication**

  * **Supabase Auth:** Handles user registration, login (email/pass, social providers), password resets, JWT generation/verification, anonymous users, and session management.
  * FastAPI backend verifies JWTs received from the frontend using Supabase JWK endpoint.
  * User identity (UUID) from verified JWT used for data access authorization.
  * **Supabase Row Level Security (RLS)** enforced at the database level.
* **Input/Output Security**

  * Input validation with Pydantic models in FastAPI.
  * Input sanitization with `bleach` in FastAPI before LLM interaction.
  * LLM prompt injection protection strategies.
* **API Security**

  * Rate limiting (see FR-17).
  * CORS policy configuration in FastAPI.
  * Secure handling of Supabase Service Role Key in the backend.
  * Audit logging for security events (Supabase Auth logs, backend logs).

#### **Observability Stack**

* **Logging**

  * Structured logging in FastAPI (`structlog`).
  * Centralized logging platform for FastAPI logs (e.g., Datadog, ELK, Loki).
  * Utilize Supabase's built-in logging for Auth and Database events.
* **Metrics**

  * Prometheus integration for FastAPI metrics.
  * Custom metrics for LLM interactions.
  * Monitor Supabase platform metrics via its dashboard/API.
* **Monitoring**

  * Health check endpoints in FastAPI.
  * Real-time dashboards (Grafana, Datadog) combining FastAPI and Supabase metrics/logs.
  * Alerting based on combined observability data.

### **Frontend Architecture (Next.js + Supabase)**

#### **Framework & Core Technologies**

* **React 18+** \- Component-based UI.
* **Next.js 14+** \- SSR, API routes (optional, primarily for BFF pattern if needed, main API is FastAPI), routing.
* **TypeScript** \- Type safety.
* **Supabase JavaScript Library (`@supabase/supabase-js`)** - Primary interface for Auth and Database interactions from the client-side.

#### **State Management**

* **Application State**

  * Manage Auth state using `@supabase/supabase-js` (`onAuthStateChange`).
  * Global state management (optional): React Context, Zustand, or Redux Toolkit for non-auth global state.
  * Data fetching: RTK Query, SWR, React Query, or direct `@supabase/supabase-js` calls.
  * Leverage Supabase Realtime subscriptions for live data updates if needed.
* **Form Management**

  * React Hook Form + Zod for form validation.

#### **UI Components & Styling**

* **Component Library**

  * Custom components or library like shadcn/ui.
  * Storybook for documentation.
* **Styling**

  * TailwindCSS.

#### **Client-Side Performance**

* **Optimization Techniques**

  * Standard Next.js optimizations (code splitting, dynamic imports).
  * Virtualized lists for long conversations.
  * Memoization.
* **Caching Strategy**

  * Data fetching libraries (SWR, React Query) provide caching.
  * Supabase client library manages auth session persistence.

#### **Testing Strategy**

* **Unit Testing**

  * React Testing Library + Jest.
  * Mock `@supabase/supabase-js` interactions.
  * Mock backend API calls (FastAPI).
* **End-to-End Testing**

  * Cypress or Playwright, including Auth flows (mocking Supabase UI or using test users).

### **DevOps & Deployment**

#### **Containerization (for FastAPI Backend)**

* **Docker**
  * Multi-stage builds for FastAPI service.
  * Docker Compose for local development (FastAPI, Redis, RabbitMQ if used).

#### **Orchestration (for FastAPI Backend)**

* **Docker Swarm / Kubernetes / Serverless Container Service**
  * Manage deployment, scaling, and updates for the FastAPI service.

#### **CI/CD Pipeline**

* **GitHub Actions (or similar)**
  * Linting, testing (backend & frontend).
  * Security scanning.
  * Build Docker image for FastAPI.
  * Deploy FastAPI service.
  * Deploy Next.js frontend (e.g., Vercel, Netlify).
  * Run Supabase migrations (`supabase db push` or schema migration tools).

#### **Infrastructure**

* **Supabase Platform:** Manages Database, Auth, Storage, Edge Functions (if used).
* **Hosting for FastAPI:** Cloud provider (AWS, GCP, Azure) using container services or VMs.
* **Hosting for Next.js:** Vercel, Netlify, or cloud provider.
* **Reverse Proxy (Optional):** Nginx/Cloudflare in front of FastAPI if needed for caching, WAF, load balancing.
* **DNS Management.**

#### **Backup & Disaster Recovery**

* **Database:** Rely on Supabase's automated backups and Point-in-Time Recovery (PITR).
* **FastAPI Service:** Infrastructure as Code (Terraform/Pulumi), stateless design for easy recovery.
* **Configuration/Secrets:** Securely managed backups.

## **8\. Implementation Details**

### **Backend Implementation Notes (FastAPI)**

#### **FastAPI Application Structure**

(Largely similar to original, but `db`, `security`, `auth` components adapted for Supabase)

backend/
├── app/
│   ├── api/
│   │   ├── deps.py           # Dependency injection (including Supabase client/auth verification)
│   │   ├── endpoints/
│   │   │   ├── conversation.py  # Conversation CRUD, interacts w/ Supabase via service
│   │   │   └── health.py
│   │   └── router.py
│   ├── core/
│   │   ├── config.py         # Handles SUPABASE_URL, SUPABASE_SERVICE_KEY, LLM keys etc.
│   │   ├── security.py       # JWT verification using Supabase JWKs
│   │   └── logging.py
│   ├── db/                   # Supabase interaction logic (potentially simplified)
│   │   └── supabase_client.py # Initialize Supabase client (service role)
│   ├── llm/                  # (Unchanged) LLM Abstraction
│   ├── schemas/              # Pydantic models (may need UUIDs for user IDs)
│   ├── services/             # Business logic (interacts with Supabase via client)
│   │   └── conversation.py   # Uses Supabase client for DB operations
│   └── utils/
├── supabase/                 # Supabase local dev config / migrations
│   └── migrations/           # SQL migration files
├── tests/                    # Test suite (mocking Supabase)
├── Dockerfile                # Production Docker image for FastAPI
├── docker-compose.yml        # Local dev (FastAPI, maybe Redis/RabbitMQ)
├── pyproject.toml
└── .env.example              # Include SUPABASE_URL, SUPABASE_SERVICE_KEY

#### **Key Python Requirements**

```toml
[tool.poetry.dependencies]
python = "^3.11"
fastapi = "^0.110.0"
uvicorn = {extras = ["standard"], version = "^0.27.0"}
pydantic = {extras = ["email"], version = "^2.5.2"}
# Replaces SQLAlchemy, asyncpg, Alembic, jose, passlib
supabase-py = "^2.x.x" # Check latest version
# Optional (keep if needed)
redis = {extras = ["hiredis"], version = "^5.0.1"}
motor = "^3.3.2"
aio-pika = "^9.3.1"
# LLM & Observability (Unchanged)
openai = "^1.13.3"
anthropic = "^0.14.0"
google-generativeai = "^0.3.1"
prometheus-fastapi-instrumentator = "^6.1.0"
structlog = "^24.1.0"
slowapi = "^0.1.9"
bleach = "^6.1.0"
# JWT verification
httpx = "^0.27.0" # For fetching JWKs
python-jose = {extras = ["cryptography"], version = "^3.3.0"} # Still needed for JWT decoding/verification
```

#### **FastAPI Supabase Integration Example (Dependencies)**

```python
# In app/core/config.py
from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    SUPABASE_URL: str
    SUPABASE_SERVICE_KEY: str
    SUPABASE_JWT_SECRET: str # For verification (or use JWKs endpoint)
    # ... other settings ...

    class Config:
        env_file = '.env'

settings = Settings()

# In app/db/supabase_client.py
from supabase import create_client, Client
from app.core.config import settings

supabase: Client = create_client(settings.SUPABASE_URL, settings.SUPABASE_SERVICE_KEY)

# In app/core/security.py
import httpx
from jose import jwt, jwk
from jose.exceptions import JWTError
from fastapi import HTTPException, status, Depends
from fastapi.security import OAuth2PasswordBearer
from app.core.config import settings
from typing import Optional, Dict

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token", auto_error=False) # Dummy URL

async def get_jwks() -> Dict[str, object]:
    # In production, cache this result
    async with httpx.AsyncClient() as client:
        response = await client.get(f"{settings.SUPABASE_URL}/auth/v1/jwks")
        response.raise_for_status()
        return response.json()

async def get_current_user(token: Optional[str] = Depends(oauth2_scheme)) -> Dict:
    """Verifies Supabase JWT and returns user payload"""
    if token is None:
        # Handle anonymous user case if needed, or raise error
        # For anonymous users Supabase might issue a different kind of token
        # or the frontend won't send one. We might need a separate dependency
        # or logic to handle 'truly' anonymous vs Supabase anonymous.
        # Assuming for now API calls require a valid token (incl. anon user token).
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Not authenticated",
            headers={"WWW-Authenticate": "Bearer"},
        )

    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        jwks = await get_jwks()
        header = jwt.get_unverified_header(token)
        kid = header.get("kid")
        
        if not kid:
             raise credentials_exception

        rsa_key = {}
        for key in jwks["keys"]:
            if key["kid"] == kid:
                rsa_key = {
                    "kty": key["kty"],
                    "kid": key["kid"],
                    "use": key["use"],
                    "n": key["n"],
                    "e": key["e"],
                }
                break
        
        if not rsa_key:
             raise credentials_exception

        payload = jwt.decode(
            token,
            rsa_key,
            algorithms=["RS256"],
            audience="authenticated", # Default Supabase audience
            issuer=f"{settings.SUPABASE_URL}/auth/v1"
        )
        user_id: str = payload.get("sub")
        role: str = payload.get("role")
        # You can add more checks here based on payload claims
        if user_id is None:
            raise credentials_exception
        # Return essential user info from token
        return {"user_id": user_id, "role": role, "token": token}
    except JWTError as e:
        print(f"JWT Error: {e}") # Log properly
        raise credentials_exception
    except Exception as e:
        print(f"General Auth Error: {e}") # Log properly
        raise credentials_exception

# In app/api/deps.py
from app.db.supabase_client import supabase
from app.core.security import get_current_user

def get_supabase_client() -> Client:
    return supabase

# Dependency for authenticated user ID
async def get_current_user_id(user: Dict = Depends(get_current_user)) -> str:
    return user["user_id"]

```

#### **FastAPI Route Implementation Example (Using Supabase User)**

```python
# In app/api/endpoints/conversation.py
from fastapi import APIRouter, Depends, HTTPException, BackgroundTasks
from app.api.deps import get_supabase_client, get_current_user_id, get_llm_client # Assuming get_llm_client exists
from app.schemas.conversation import ConversationCreate, ConversationResponse # Adapt schemas if needed (e.g., user_id is UUID)
from app.services.conversation import ConversationService # Adapt service
from app.llm.base import BaseLLMClient
from supabase import Client
import structlog

logger = structlog.get_logger(__name__)
router = APIRouter()
# Add rate limiting if needed (e.g., using slowapi)

@router.post("/message", response_model=ConversationResponse)
# Apply rate limiting decorator if using slowapi
async def create_message(
    payload: ConversationCreate, # Ensure this schema matches frontend
    background_tasks: BackgroundTasks,
    user_id: str = Depends(get_current_user_id), # Get user ID from verified Supabase token
    supabase_client: Client = Depends(get_supabase_client),
    llm_client: BaseLLMClient = Depends(get_llm_client),
):
    """Process a new message, associated with the Supabase user"""
    try:
        # Pass Supabase client and LLM client to the service
        service = ConversationService(supabase_client, llm_client)

        # Service now uses user_id (UUID string from Supabase)
        response = await service.process_message(
            user_id=user_id,
            conversation_id=payload.conversation_id, # May be None for first message
            message=payload.message
        )

        # Track metrics (pass Supabase user_id)
        background_tasks.add_task(
            service.track_interaction,
            user_id=user_id,
            conversation_id=response.conversation_id,
            tokens_used=response.token_usage
        )

        return response
    except Exception as e:
        logger.exception(
            "Error processing message",
            user_id=user_id,
            conversation_id=payload.conversation_id,
            error=str(e)
        )
        raise HTTPException(
            status_code=500,
            detail="An error occurred while processing your message"
        )

```

#### **Database Schema & RLS (Conceptual)**

*   **Tables:**
    *   `conversations` (id UUID PK, user_id UUID FK references auth.users, title TEXT, created_at TIMESTAMPTZ, ...)
    *   `messages` (id UUID PK, conversation_id UUID FK references conversations, user_id UUID FK references auth.users, role TEXT, content TEXT, metadata JSONB, created_at TIMESTAMPTZ, ...)
*   **RLS Policies:**
    *   `conversations`: Enable RLS. Policy allows SELECT/INSERT/UPDATE/DELETE if `auth.uid() = user_id`.
    *   `messages`: Enable RLS. Policy allows SELECT/INSERT/UPDATE/DELETE if `auth.uid() = user_id`.
    *   Consider service role bypass for backend operations if needed, but prefer user-context operations where possible.

#### **Service Layer (Conceptual)**

```python
# In app/services/conversation.py
from supabase import Client
from app.llm.base import BaseLLMClient # Assuming LLM logic is separate
# Import schemas

class ConversationService:
    def __init__(self, supabase: Client, llm_client: BaseLLMClient):
        self.db = supabase # Use Supabase client for DB ops
        self.llm = llm_client

    async def process_message(self, user_id: str, conversation_id: Optional[str], message: str):
        # 1. Retrieve conversation history (using user_id for RLS)
        history = []
        if conversation_id:
            # Fetch messages for this conversation WHERE user_id = auth.uid()
            data = await self.db.table('messages')\
                .select('role, content')\
                .eq('conversation_id', conversation_id)\
                .order('created_at', desc=False)\
                .execute()
            history = data.data

        # 2. Call LLM
        llm_response = await self.llm.generate_response(message, history) # Adapt LLM call signature

        # 3. Store user message and AI response in DB
        # Ensure conversation exists or create new one if conversation_id is None
        if not conversation_id:
             # Create new conversation record associated with user_id
             conv_data = await self.db.table('conversations')\
                .insert({"user_id": user_id, "title": message[:50]})\
                .execute()
             conversation_id = conv_data.data[0]['id']

        # Insert user message
        await self.db.table('messages')\
            .insert({"conversation_id": conversation_id, "user_id": user_id, "role": "user", "content": message})\
            .execute()
        # Insert assistant message
        await self.db.table('messages')\
            .insert({
                "conversation_id": conversation_id,
                "user_id": user_id, # Associate AI message with user for RLS simplicity
                "role": "assistant",
                "content": llm_response["answer"],
                "metadata": { # Store LLM metadata
                     "follow_up": llm_response["follow_up_questions"],
                     "token_usage": llm_response["token_usage"]
                 }
             })\
            .execute()

        # 4. Format and return response (adapt ConversationResponse schema)
        return ConversationResponse(
             conversation_id=conversation_id,
             answer=llm_response["answer"],
             # ... other fields
        )

    async def track_interaction(self, user_id: str, conversation_id: str, tokens_used: dict):
        # Logic to log/metric track interaction data
        pass

    # Add methods for getting conversations, deleting, etc., always scoped by user_id
    async def get_user_conversations(self, user_id: str):
         data = await self.db.table('conversations')\
            .select('*')\
            .eq('user_id', user_id)\
            .order('created_at', desc=True)\
            .execute()
         return data.data
```

### **Frontend Implementation Notes (Next.js)**

#### **Authentication Context Provider (using Supabase)**

```typescript
// In src/contexts/AuthContext.tsx
import React, { createContext, useState, useEffect, useContext, ReactNode } from 'react';
import { Session, User } from '@supabase/supabase-js';
import { supabase } from '../lib/supabaseClient'; // Your Supabase client instance

interface AuthContextData {
  session: Session | null;
  user: User | null;
  isLoading: boolean;
  isGuest: boolean; // Based on user.is_anonymous
  login: (provider: 'google' | 'github' /* etc */) => Promise<void>; // Example social login
  loginWithPassword: (email: string, password: string) => Promise<void>;
  logout: () => Promise<void>;
  signUp: (email: string, password: string) => Promise<void>;
  linkAnonymousUser: (email: string, password: string) => Promise<void>; // For converting guest
}

const AuthContext = createContext<AuthContextData>({} as AuthContextData);

interface AuthProviderProps {
  children: ReactNode;
}

export const AuthProvider: React.FC<AuthProviderProps> = ({ children }) => {
  const [session, setSession] = useState<Session | null>(null);
  const [user, setUser] = useState<User | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [isGuest, setIsGuest] = useState(true);

  useEffect(() => {
    setIsLoading(true);
    // Check initial session
    supabase.auth.getSession().then(({ data: { session } }) => {
      setSession(session);
      setUser(session?.user ?? null);
      setIsGuest(session?.user?.is_anonymous ?? true);
      setIsLoading(false);
    });

    // Listen for auth changes
    const { data: authListener } = supabase.auth.onAuthStateChange(
      (_event, session) => {
        setSession(session);
        setUser(session?.user ?? null);
        setIsGuest(session?.user?.is_anonymous ?? true);
        setIsLoading(false); // Ensure loading is false after initial check AND listener fires
      }
    );

    return () => {
      authListener?.subscription.unsubscribe();
    };
  }, []);

  const login = async (provider: any) => {
    const { error } = await supabase.auth.signInWithOAuth({ provider });
    if (error) throw error;
  };

  const loginWithPassword = async (email: string, password: string) => {
      const { error } = await supabase.auth.signInWithPassword({ email, password });
      if (error) throw error;
  }

  const logout = async () => {
    const { error } = await supabase.auth.signOut();
    if (error) throw error;
  };

  const signUp = async (email: string, password: string) => {
    const { error } = await supabase.auth.signUp({ email, password });
    if (error) throw error;
    // Handle email confirmation if required
  };

  const linkAnonymousUser = async (email: string, password: string) => {
      // This function might need adjustment based on exact Supabase capabilities
      // for linking anonymous users. Often involves signing up and then potentially
      // backend logic to transfer data if RLS doesn't handle it automatically
      // via user_id updates. Supabase 'updateUser' might be relevant here.
      // Placeholder: Sign up the user. Data transfer might need a backend endpoint.
      const { data, error } = await supabase.auth.updateUser({ email, password });
       if (error) {
           // Handle error, maybe user needs to sign in first?
           // Or if email is taken etc.
            if (error.message.includes("User not found")) {
                 // If anon user needs sign-up first
                 await signUp(email, password);
            } else {
                 throw error;
            }
       }
      // Potentially call backend endpoint to transfer data if needed
  };

  const value = {
    session,
    user,
    isLoading,
    isGuest,
    isAuthenticated: !!session?.user && !session.user.is_anonymous,
    login,
    loginWithPassword,
    logout,
    signUp,
    linkAnonymousUser,
  };

  return (
    <AuthContext.Provider value={value}>
      {!isLoading && children}
    </AuthContext.Provider>
  );
};

export function useAuth(): AuthContextData {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
}
```

#### **API Client Setup (for FastAPI)**

```typescript
// In src/services/apiClient.ts (Example for calling FastAPI backend)
import axios from 'axios';
import { supabase } from '../lib/supabaseClient'; // Your Supabase client instance

const apiClient = axios.create({
  baseURL: process.env.NEXT_PUBLIC_API_URL || 'http://localhost:8000', // Your FastAPI backend URL
});

// Add an interceptor to automatically add the Supabase Auth token
apiClient.interceptors.request.use(async (config) => {
  const { data: { session } } = await supabase.auth.getSession();
  const token = session?.access_token;

  if (token) {
    config.headers.Authorization = `Bearer ${token}`;
  }
  return config;
}, (error) => {
  return Promise.reject(error);
});

export { apiClient };

// Usage Example:
// import { apiClient } from './services/apiClient';
// const response = await apiClient.post('/message', { message: 'Hello' });
```

#### **Guest Prompt / Conversion Component**

```typescript
// In src/components/GuestPrompt.tsx
import React, { useState } from 'react';
import { useAuth } from '../contexts/AuthContext';
// Import your Modal and Form components

export const GuestPrompt: React.FC = () => {
  const { isGuest, linkAnonymousUser, signUp } = useAuth(); // Use link/signup from context
  const [isSignupModalOpen, setIsSignupModalOpen] = useState(false);
  const [formData, setFormData] = useState({ email: '', password: '', confirmPassword: '' });
  const [errors, setErrors] = useState<Record<string, string>>({});
  const [isSubmitting, setIsSubmitting] = useState(false);

  if (!isGuest) return null;

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setErrors({}); // Clear previous errors
    if (formData.password !== formData.confirmPassword) {
      setErrors({ confirmPassword: 'Passwords do not match' });
      return;
    }
    setIsSubmitting(true);
    try {
      // Try linking first (if Supabase supports it well for anonymous users)
      // If linking fails (e.g., needs signup first), try signup.
      // Adjust logic based on how Supabase handles anonymous user conversion.
      await linkAnonymousUser(formData.email, formData.password);
      setIsSignupModalOpen(false); // Close modal on success
    } catch (error: any) {
      console.error("Signup/Link error:", error);
       // Use Supabase error messages if available
      setErrors({ form: error.message || 'Failed to create account. The email might be taken.' });
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <>
      <div className="guest-banner bg-yellow-100 p-2 text-center">
        <p className="text-sm">
          You're currently using PawaIT as a guest (history is device-specific).{' '}
          <button
            onClick={() => setIsSignupModalOpen(true)}
            className="text-blue-600 hover:underline"
          >
            Sign up
          </button>
          {' '}to save your chats across devices!
        </p>
      </div>

      {isSignupModalOpen && (
        {/* Your Modal Component */}
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
          <div className="bg-white p-6 rounded-lg w-full max-w-md">
            <h2 className="text-xl font-bold mb-4">Create Account</h2>
            <p className="mb-4 text-gray-600">
                Sign up to save your chat history across devices.
            </p>
             {errors.form && (
              <div className="bg-red-100 text-red-700 p-3 rounded mb-4">
                {errors.form}
              </div>
            )}
            <form onSubmit={handleSubmit}>
               {/* Email Input */}
               <div className="mb-4">
                 <label className="block text-gray-700 mb-1">Email</label>
                 <input
                   type="email" required
                   value={formData.email}
                   onChange={e => setFormData({...formData, email: e.target.value})}
                   className="w-full p-2 border rounded"
                 />
               </div>
               {/* Password Input */}
               <div className="mb-4">
                 <label className="block text-gray-700 mb-1">Password</label>
                 <input
                   type="password" required minLength={6} // Supabase default min length
                   value={formData.password}
                   onChange={e => setFormData({...formData, password: e.target.value})}
                   className="w-full p-2 border rounded"
                 />
               </div>
               {/* Confirm Password Input */}
                <div className="mb-6">
                 <label className="block text-gray-700 mb-1">Confirm Password</label>
                 <input
                   type="password" required
                   value={formData.confirmPassword}
                   onChange={e => setFormData({...formData, confirmPassword: e.target.value})}
                   className="w-full p-2 border rounded"
                 />
                 {errors.confirmPassword && (
                   <p className="text-red-500 text-sm mt-1">{errors.confirmPassword}</p>
                 )}
               </div>
               {/* Buttons */}
                <div className="flex justify-end gap-2">
                 <button
                   type="button"
                   onClick={() => setIsSignupModalOpen(false)}
                   className="px-4 py-2 text-gray-700 border rounded"
                 >
                   Cancel
                 </button>
                 <button
                   type="submit"
                   disabled={isSubmitting}
                   className="px-4 py-2 bg-blue-600 text-white rounded disabled:bg-blue-400"
                 >
                   {isSubmitting ? 'Creating...' : 'Create Account'}
                 </button>
               </div>
            </form>
          </div>
        </div>
      )}
    </>
  );
};

```

#### **Data Models & Types**

```typescript
// In src/types/supabase.ts - Auto-generated via Supabase CLI gen types is recommended
// npx supabase gen types typescript --project-id <your-project-id> --schema public > src/types/supabase.ts
export type Json =
  | string
  | number
  | boolean
  | null
  | { [key: string]: Json | undefined }
  | Json[]

export interface Database {
  public: {
    Tables: {
      conversations: {
        Row: { // The data type for SELECT
          id: string // UUID
          user_id: string // UUID from auth.users
          title: string | null
          created_at: string
        }
        Insert: { // The data type for INSERT
          id?: string // UUID generated by DB
          user_id: string // Must provide on insert
          title?: string | null
          created_at?: string
        }
        Update: { // The data type for UPDATE
          id?: string
          user_id?: string
          title?: string | null
          created_at?: string
        }
        Relationships: [
          {
            foreignKeyName: "conversations_user_id_fkey"
            columns: ["user_id"]
            referencedRelation: "users" // References auth.users table
            referencedColumns: ["id"]
          }
        ]
      }
      messages: {
        Row: {
          id: string // UUID
          conversation_id: string // UUID
          user_id: string // UUID - For RLS
          role: "user" | "assistant"
          content: string
          metadata: Json | null // For token counts, follow-ups etc.
          created_at: string
        }
        Insert: {
          id?: string
          conversation_id: string
          user_id: string
          role: "user" | "assistant"
          content: string
          metadata?: Json | null
          created_at?: string
        }
        Update: {
          id?: string
          conversation_id?: string
          user_id?: string
          role?: "user" | "assistant"
          content?: string
          metadata?: Json | null
          created_at?: string
        }
        Relationships: [
          {
            foreignKeyName: "messages_conversation_id_fkey"
            columns: ["conversation_id"]
            referencedRelation: "conversations"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "messages_user_id_fkey"
            columns: ["user_id"]
            referencedRelation: "users"
            referencedColumns: ["id"]
          }
        ]
      }
    }
    Views: { [_ in never]: never }
    Functions: { [_ in never]: never }
    Enums: { [_ in never]: never }
    CompositeTypes: { [_ in never]: never }
  }
}

// In src/types/app.ts (Custom app types combining Supabase types)
import { Database } from './supabase';

export type Conversation = Database['public']['Tables']['conversations']['Row'];
export type Message = Database['public']['Tables']['messages']['Row'];

export interface ConversationWithMessages extends Conversation {
    messages: Message[];
}

```

### **Testing Requirements**

*   **Backend (FastAPI):**
    *   Unit tests for services, mocking `supabase-py` client interactions (e.g., using `unittest.mock`).
    *   Integration tests for API endpoints, using a test Supabase instance or more elaborate mocking. Test JWT verification logic. Test RLS enforcement indirectly by asserting correct data scoping based on mock user IDs.
*   **Frontend (Next.js):**
    *   Component tests using React Testing Library, mocking `useAuth` context and `@supabase/supabase-js` client functions.
    *   Mock API calls to the FastAPI backend.
    *   End-to-end tests (Cypress/Playwright) covering login/signup flows (potentially using Supabase test users or mocking layers) and core chat functionality.
*   **Supabase:**
    *   Test RLS policies using Supabase's built-in SQL testing features (`pg_prove`).
    *   Test database functions/triggers if any are created.

</rewritten_file> 